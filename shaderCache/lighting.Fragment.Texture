#version 130
/*“Copyright 2009-2013 DIVIDE-Studio”*/
#define MAX_LIGHT_COUNT 4
#define MAX_SHADOW_CASTING_LIGHTS 2
#extension GL_EXT_texture_array : enable
#extension GL_EXT_gpu_shader4 : enable
#define USE_VBO_DATA
#define DEFINE_PLACEHOLDER
#line 8

varying vec3 vPixToLightTBN[MAX_LIGHT_COUNT];
varying vec3 vPixToLightMV[MAX_LIGHT_COUNT];
varying vec3 vPixToEyeTBN[MAX_LIGHT_COUNT];

varying vec2 _texCoord;
varying vec3 _normalMV;
varying vec4 _vertexMV;

uniform mat4  material;
uniform float opacity;

//Textures
//0 -> no texture
//1 -> use texDiffuse0
//2 -> add texDiffuse0 + texDiffuse1
uniform int textureCount;
uniform sampler2D texDiffuse0;
uniform int       texDiffuse0Op;
uniform sampler2D texDiffuse1;
uniform int       texDiffuse1Op;

//true -> use opacity map
uniform bool hasOpacity;
//true -> use specular map 
uniform bool hasSpecular;
//Opacity and specular maps
uniform sampler2D opacityMap;
uniform sampler2D specularMap;

const int REPLACE    = 0;
const int MODULATE   = 1;
const int DECAL      = 2;
const int BLEND      = 3;
const int ADD        = 4;
const int SMOOTH_ADD = 5;
const int SIGNED_ADD = 6;
const int DIVIDE     = 7;
const int SUBSTRACT  = 8;
const int COMBINE    = 9;

void applyTexture(in sampler2D texUnit, in int type, in int index, in vec2 uv, inout vec4 color){
    // Read from the texture
    vec4 texture = texture(texUnit,uv);
   
    if (type == REPLACE){
        color = texture;

    } else if (type == MODULATE){
        color *= texture;

    } else if (type == DECAL){
        vec3 temp = mix(color.rgb, texture.rgb, texture.a);
        color = vec4(temp, color.a);

    }else if (type == BLEND) {
        vec3 temp = mix(color.rgb, gl_TextureEnvColor[index].rgb, texture.rgb);
        color = vec4(temp, color.a * texture.a);

    }else if (type == ADD){
        color.rgb += texture.rgb;
        color.a   *= texture.a;
        color = clamp(color, 0.0, 1.0);

	} else if (type == SMOOTH_ADD) {
		color = (color + texture) - (color * texture);

	} else if (type == SIGNED_ADD){
		color += (texture - 0.5f);

	}else if (type == DIVIDE){
		color /= texture;

	}else if (type == SUBSTRACT) {
		color -= texture;

	}else {
        color = clamp(texture * color, 0.0, 1.0);
    }
}

#define LIGHT_DIRECTIONAL		0
#define LIGHT_OMNIDIRECTIONAL	1
#define LIGHT_SPOT				2

uniform int lightType[MAX_LIGHT_COUNT];
uniform int light_count;

///Global NDotL, basically
float iDiffuse;



void phong_pointLight(in int _light, 
					  in vec4 _specularIn, 
					  in vec3 LightVector, //normalized value
					  in vec3 NormalVector,//normalized value
					  in vec3 EyeVector,   //normalized value
					  inout vec4 _ambient,
					  inout vec4 _diffuse,
					  inout vec4 _specular)
{
	//get the distance from surface to light
	float distance = length(vPixToEyeTBN[_light]);
	float attenuation = 1.0/(gl_LightSource[_light].constantAttenuation + 
		               gl_LightSource[_light].linearAttenuation * distance + 
					   gl_LightSource[_light].quadraticAttenuation * distance * distance);
	attenuation = max(attenuation, 0.0);

	//Diffuse intensity
	iDiffuse = max(dot(LightVector, NormalVector), 0.0);
	//Specular intensity based on material shininess
	float iSpecular = pow(clamp(dot(reflect(-LightVector, NormalVector), EyeVector), 0.0, 1.0), material[3].x );
	
	//add the lighting contributions
	_ambient += material[0] * gl_LightSource[_light].ambient * attenuation;
	_diffuse += material[1] * gl_LightSource[_light].diffuse * iDiffuse * attenuation;
	_specular += _specularIn * gl_LightSource[_light].specular * iSpecular * attenuation;
}

const float cos_outer_cone_angle = 0.8; // 36 degrees

void phong_spotLight(in int _light, 
					 in vec4 _specularIn, 
					 in vec3 LightVector, //normalized value
					 in vec3 NormalVector,//normalized value
					 in vec3 EyeVector,   //normalized value
					 inout vec4 _ambient,
					 inout vec4 _diffuse,
					 inout vec4 _specular)
{
	//get the distance from surface to light
	float distance = length(vPixToEyeTBN[_light]);
	vec3  spotDirection =  normalize(gl_LightSource[_light].spotDirection);
	float cos_cur_angle = dot(-LightVector, spotDirection);
	float cos_inner_cone_angle = gl_LightSource[_light].spotCosCutoff;
	float cos_inner_minus_outer_angle =  cos_inner_cone_angle - cos_outer_cone_angle;
	float spot = 0.0;
	spot = clamp((cos_cur_angle - cos_outer_cone_angle) /  cos_inner_minus_outer_angle, 0.0, 1.0);
	//Diffuse intensity
	iDiffuse = max(dot(LightVector, NormalVector), 0.0);
	float spotEffect;
	if(iDiffuse > 0.0){
		spotEffect = pow(spotEffect, gl_LightSource[_light].spotExponent);
		float attenuation = spotEffect/(gl_LightSource[_light].constantAttenuation + 
								  gl_LightSource[_light].linearAttenuation * distance + 
							      gl_LightSource[_light].quadraticAttenuation * distance * distance);
		attenuation = max(attenuation, 0.0);
		//Specular intensity based on material shininess
		float iSpecular = pow(clamp(dot(reflect(-LightVector, NormalVector), EyeVector), 0.0, 1.0), material[3].x );
		//add the lighting contributions
		_ambient += material[0] * gl_LightSource[_light].ambient * attenuation;;
		_diffuse += material[1] * gl_LightSource[_light].diffuse * iDiffuse * attenuation;;
		_specular += _specularIn * gl_LightSource[_light].specular * iSpecular * attenuation;
		
	}
}



void phong_directionalLight(in int _light, 
							in vec4 _specularIn, 
							in vec3 LightVector, //normalized value
							in vec3 NormalVector,//normalized value
							in vec3 EyeVector,   //normalized value
							inout vec4 _ambient,
							inout vec4 _diffuse,
							inout vec4 _specular)
{
	///Lambert term for the position vector
	iDiffuse = max(dot(LightVector, NormalVector), 0.0);
	//Specular intensity based on material shininess
	float iSpecular = pow(clamp(dot(reflect(-LightVector, NormalVector), EyeVector), 0.0, 1.0), material[3].x );

	//add the lighting contributions
	_ambient  += gl_LightSource[_light].ambient * material[0];
	_diffuse  += gl_LightSource[_light].diffuse * material[1] *  iDiffuse;
	_specular += gl_LightSource[_light].specular * _specularIn * iSpecular;
}

varying vec4 shadowCoord[MAX_SHADOW_CASTING_LIGHTS];
uniform bool enable_shadow_mapping;

uniform sampler2DArrayShadow texDepthMapFromLightArray;
uniform samplerCubeShadow    texDepthMapFromLightCube;
uniform sampler2DShadow texDepthMapFromLight0;
uniform sampler2DShadow texDepthMapFromLight1;
uniform sampler2DShadow texDepthMapFromLight2;
uniform sampler2DShadow texDepthMapFromLight3;
uniform sampler2D texDiffuseProjected;
uniform float    mixWeight;
////////////////////

uniform float lightBleedBias;


float linearStep(in float min, in float max, in float v){
  return clamp((v-min)/(max-min),0.0,1.0);
}  

void ReduceLightBleeding(inout float p_max)  {  
   p_max = linearStep(lightBleedBias, 1, p_max);  
}  

float chebyshevUpperBound( float distance){

	// We retrive the two moments previously stored (depth and depth*depth)
	//vec2 moments = texture(texDepthMapFromLightArray,posInDM.xyz).xy;
	vec2 moments;
		
	// Surface is fully lit. as the current fragment is before the light occluder
	if (distance <= moments.x)
		return 1.0 ;
	
	// The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check
	// How likely this pixel is to be lit (p_max)
	float variance = moments.y - (moments.x*moments.x);
	variance = max(variance,0.00002);
	
	float d = distance - moments.x;
	float p_max = variance / (variance + d*d);
	ReduceLightBleeding(p_max);
	return p_max;
}
	
float filterShadow(in sampler2DArrayShadow stex, in vec4 posInDM){
	float ret =  texture(stex, posInDM);
	if ((ret - 1) * ret * iDiffuse != 0) {
		ret *= 0.25;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1,-1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1, 0)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1, 1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 0,-1)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 0, 1)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1,-1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1, 0)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1, 1)).r * 0.0625;
	}
	return ret;
}

void applyShadowDirectional(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;
			
	// transform this fragment's position from view space to scaled light clip space
	// such that the xy coordinates are in [0;1]
	// note there is no need to divide by w for othogonal light sources
	vec4 shadow_coord = shadowCoord[_shadowIndex];
	
	// SHADOW MAPS
	vec3 vPixPosInDepthMap;
				
	float tOrtho[3];
	tOrtho[0] = 5.0;
	tOrtho[1] = 10.0;
	tOrtho[2] = 50.0;
	vec4 posInDM;
	for(int i = 0; i < 3; i++){
		vPixPosInDepthMap = vec3(shadow_coord.xy/tOrtho[i], shadow_coord.z) / shadow_coord.w;
		vPixPosInDepthMap = (vPixPosInDepthMap + 1.0) * 0.5;
		if(vPixPosInDepthMap.x >= 0.0 && vPixPosInDepthMap.y >= 0.0 && vPixPosInDepthMap.x <= 1.0 && vPixPosInDepthMap.y <= 1.0){
			posInDM.xy = vPixPosInDepthMap.xy;
			posInDM.w = vPixPosInDepthMap.z;
			posInDM.z = i;
			break; // no need to continue
		}
	}
	//shadow = chebyshevUpperBound(shadow_coord.w);
	shadow = filterShadow(texDepthMapFromLightArray, posInDM);

}


float filterFinalShadow(sampler2DShadow depthMap,vec3 vPosInDM){
	// Gaussian 3x3 filter
	float vDepthMapColor = texture(depthMap, vPosInDM);
	float fShadow = 0.0;
	float Z_TEST_SIGMA = 0.0001f;
	if((vDepthMapColor+Z_TEST_SIGMA) < vPosInDM.z){
		fShadow = vDepthMapColor * 0.25;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, -1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, 0)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, 1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 0, -1)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 0, 1)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, -1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, 0)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, 1)) * 0.0625;

		fShadow = clamp(fShadow, 0.0, 1.0);
	}else{
		fShadow = 1.0;
	}
	return fShadow;
}

void applyShadowSpot(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;

	// SHADOW MAPS
	vec3 vPixPosInDepthMap;

	vPixPosInDepthMap = shadowCoord[_shadowIndex].xyz/shadowCoord[_shadowIndex].w;
	vPixPosInDepthMap = (vPixPosInDepthMap + 1.0) * 0.5;	
	vec4 vDepthMapColor;
	switch(_shadowIndex){
		default:
		case 0:	shadow =  filterFinalShadow(texDepthMapFromLight0, vPixPosInDepthMap); break;
		case 1:	shadow =  filterFinalShadow(texDepthMapFromLight1, vPixPosInDepthMap); break;
		case 2: shadow =  filterFinalShadow(texDepthMapFromLight2, vPixPosInDepthMap); break;
		case 3: shadow =  filterFinalShadow(texDepthMapFromLight3, vPixPosInDepthMap); break;
	};
}


void applyShadowPoint(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;
	
	// SHADOW MAPS
	vec4 position_ls = gl_LightSource[_shadowIndex].position;
	vec4 abs_position = abs(position_ls);
	float fs_z = -max(abs_position.x, max(abs_position.y, abs_position.z));
	vec4 clip = shadowCoord[_shadowIndex] * vec4(0.0, 0.0, fs_z, 1.0);
	float depth = (clip.z / clip.w) * 0.5 + 0.5;
	shadow = texture(texDepthMapFromLightCube, vec4(position_ls.xyz, depth));
}


void projectTexture(in vec3 PoxPosInMap, inout vec4 texture){
	vec4 projectedTex = texture(texDiffuseProjected, vec2(PoxPosInMap.s, 1.0-PoxPosInMap.t));
	texture.xyz = mix(texture.xyz, projectedTex.xyz, mixWeight);
}




void applyLight(in int light, in vec3 normal,in vec4 specularIn, inout vec4 diffuse, inout vec4 ambient, inout vec4 specular, inout float shadow){
	//Normalized Light/Normal/Eye vectors in TBN space
	vec3 L = normalize(vPixToLightTBN[light]);
	vec3 V = normalize(vPixToEyeTBN[light]);
	
	if(lightType[light] == LIGHT_DIRECTIONAL){
		phong_directionalLight(light,specularIn,L,normal,V,ambient,diffuse,specular);
		if(light < MAX_SHADOW_CASTING_LIGHTS){
			applyShadowDirectional(light, shadow); 
		}
		return;
	}
	
	if(lightType[light] == LIGHT_OMNIDIRECTIONAL){
		phong_pointLight(light,specularIn,L,normal,V,ambient,diffuse,specular);
		if(light < MAX_SHADOW_CASTING_LIGHTS){
			applyShadowPoint(light, shadow); 
		}
		return;
	}

	if(lightType[light] == LIGHT_SPOT){
		phong_spotLight(light,specularIn,L,normal,V,ambient,diffuse,specular);
		if(light < MAX_SHADOW_CASTING_LIGHTS){
			applyShadowSpot(light, shadow); 
		}
		return;
	}
}

void phong_loop(in vec3 normal, in vec4 specularIn, inout vec4 diffuse, inout vec4 ambient, inout vec4 specular, inout float shadow){
	if(light_count == 0) return;
	applyLight(0, normal,specularIn,diffuse,ambient,specular,shadow);
#if MAX_LIGHT_COUNT >= 2
	if(light_count == 1) return;
	applyLight(1, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT >= 3
	if(light_count == 2) return;
	applyLight(2, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT >= 4
	if(light_count == 3) return;
	applyLight(3, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT >= 5
	if(light_count == 4) return;
	applyLight(4, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT >= 6
	if(light_count == 5) return;
	applyLight(5, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT >= 7
	if(light_count == 6) return;
	applyLight(6, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT == 8
	if(light_count == 7) return;
	applyLight(7, normal,specularIn,diffuse,ambient,specular,shadow);
#endif
#if MAX_LIGHT_COUNT > 8
	///Apply the rest of the lights
	for(int i = 8; i < MAX_LIGHT_COUNT; i++){
		if(light_count == i) return;
		applyLight(i, normal,specularIn,diffuse,ambient,specular,shadow);
	}
#endif
}


vec4 Phong(vec2 uv, vec3 vNormalTBN){
	// discard material if it is bellow opacity threshold
	if(opacity < 0.2) discard;

	if(hasOpacity ){
		vec4 alpha = texture(opacityMap, uv);
		if(alpha.a < 0.2) discard;
	}
	
	//Ambient color	
	vec4 cAmbient = gl_FrontLightModelProduct.sceneColor * material[0];
	//Diffuse color
	vec4 cDiffuse;
	//Specular color
	vec4 cSpecular;

	///this shader is generated only for nodes with at least 1 texture
	vec4 tBase;
	//Get the texture color. use Replace for the first texture
	applyTexture(texDiffuse0, texDiffuse0Op, 0, uv, tBase);
	
	//If we have a second diffuse texture
	if(textureCount > 1){
		//Apply the second texture over the first
		applyTexture(texDiffuse1, texDiffuse1Op, 0, uv, tBase);
	} 
	//If the texture's alpha channel is less than 1/3, discard current fragment
	if(tBase.a < 0.3) discard;

	float shadow = 1.0f;
	//If we have a specular map
	if(hasSpecular){//use the specular map instead
		phong_loop(normalize(vNormalTBN), texture(specularMap,uv), cDiffuse, cAmbient, cSpecular, shadow);
	}else{//Use material specular value
		phong_loop(normalize(vNormalTBN), material[2], cDiffuse, cAmbient, cSpecular, shadow);
	}

	//Add all values togheter to compute the final fragment color
	return vec4(shadow,shadow,shadow,1.0) * (cAmbient * tBase + (cDiffuse * tBase + cSpecular));	
}

uniform bool enableFog;
const float LOG2 = 1.442695;
float zDepth = gl_FragCoord.z / gl_FragCoord.w;
vec4 applyFog(in vec4 color){
	if(enableFog){
		
		float fogFactor = exp2( -gl_Fog.density * 
				   			     gl_Fog.density * 
								 zDepth * 
								 zDepth * 
								 LOG2 );
		fogFactor = clamp(fogFactor, 0.0, 1.0);

		return mix(gl_Fog.color, color, fogFactor );
	}
	return color;
}


void main (void){
	gl_FragDepth = gl_FragCoord.z;

	vec4 color = Phong(_texCoord, _normalMV);
	
	gl_FragData[0] = applyFog(color);
}
	

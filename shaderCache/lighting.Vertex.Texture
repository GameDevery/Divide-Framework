#version 130
/*“Copyright 2009-2013 DIVIDE-Studio”*/
#define MAX_LIGHT_COUNT 4
#define MAX_SHADOW_CASTING_LIGHTS 2
#extension GL_EXT_texture_array : enable
#extension GL_EXT_gpu_shader4 : enable
#define USE_VBO_DATA
#define DEFINE_PLACEHOLDER
#line 8

attribute vec3  inVertexData;
attribute vec3  inNormalData;
attribute vec2  inTexCoordData;
attribute vec3  inTangentData;
attribute vec3  inBiTangentData;

vec4  vertexData;
vec3  normalData;
vec3  tangentData;
vec3  biTangentData;

varying vec2 _texCoord;

uniform mat4 transformMatrix;
uniform mat4 parentTransformMatrix;
uniform mat4 projectionMatrix;
uniform mat4 modelViewInvMatrix;
uniform mat4 modelViewProjectionMatrix;



void computeData(void){

#if defined(USE_VBO_DATA)

		vertexData    = vec4(inVertexData,1.0);
		normalData    = inNormalData;
		_texCoord     = inTexCoordData;
		tangentData   = inTangentData;
		biTangentData = inBiTangentData;

#else
		vertexData     = gl_Vertex;
		normalData     = gl_Normal;
		_texCoord      = gl_MultiTexCoord0.xy;
		tangentData    = gl_MultiTexCoord1.xyz;
		biTangentData  = gl_MultiTexCoord2.xyz;

#endif
}



varying vec3 vPixToLightTBN[MAX_LIGHT_COUNT];
varying vec3 vPixToLightMV[MAX_LIGHT_COUNT];
varying vec3 vPixToEyeTBN[MAX_LIGHT_COUNT];
varying vec4 shadowCoord[MAX_SHADOW_CASTING_LIGHTS];

varying vec4 _vertexMV;
varying vec3 _normalMV;

uniform bool enable_shadow_mapping;
uniform int light_count;
uniform mat4 lightProjectionMatrices[MAX_SHADOW_CASTING_LIGHTS];

#define MODE_BUMP		1
#define MODE_PARALLAX	2
#define MODE_RELIEF		3

void computeLightVectorsBump(in vec3 t, in vec3 b, in vec3 n){
	vec3 tmpVec; 

	for(int i = 0; i < MAX_LIGHT_COUNT; i++){
		if(light_count == i) break;
		if(gl_LightSource[i].position.w == 0.0){
			tmpVec = -gl_LightSource[i].position.xyz;					
		}else{
			tmpVec = gl_LightSource[i].position.xyz - _vertexMV.xyz;	
		}

		vPixToLightMV[i] = tmpVec;
	
		vPixToLightTBN[i].x = dot(tmpVec, t);
		vPixToLightTBN[i].y = dot(tmpVec, b);
		vPixToLightTBN[i].z = dot(tmpVec, n);
		//View vector
		tmpVec = -_vertexMV.xyz;
		vPixToEyeTBN[i].x = dot(tmpVec, t);
		vPixToEyeTBN[i].y = dot(tmpVec, b);
		vPixToEyeTBN[i].z = dot(tmpVec, n);
	}
}


void computeLightVectorsPhong(){
	vec3 tmpVec; 

	for(int i = 0; i < MAX_LIGHT_COUNT; i++){
		if(light_count == i) break;
		vec4 vLightPosMV = gl_LightSource[i].position;	
		if(vLightPosMV.w == 0.0){ ///<Directional Light
			tmpVec = -vLightPosMV.xyz;					
		}else{///<Omni or spot. Change later if spot
			tmpVec = vLightPosMV.xyz - _vertexMV.xyz;	
		}

		vPixToLightMV[i] = tmpVec;
		vPixToLightTBN[i] = tmpVec;
		vPixToEyeTBN[i] = -_vertexMV.xyz;
	}
}


void computeLightVectors(in bool bump){

	vec3 n = normalize(gl_NormalMatrix * normalData);
	vec3 t = normalize(gl_NormalMatrix * tangentData);
	vec3 b = cross(n, t);
	_normalMV = n;
	// Transformed position 
	_vertexMV = gl_ModelViewMatrix * vertexData;
	
	if(bump == false){
		computeLightVectorsPhong();
	}else{
		computeLightVectorsBump(t,b,n);
	}

	if(enable_shadow_mapping) {
		// position multiplied by the inverse of the camera matrix
		// position multiplied by the light matrix. The vertex's position from the light's perspective
		for(int i = 0; i < MAX_SHADOW_CASTING_LIGHTS; i++){
			shadowCoord[i] = lightProjectionMatrices[i] * modelViewInvMatrix * _vertexMV;
		}
	}	
}

#if defined(ADD_FOLIAGE)
uniform vec3  scale;
uniform float grassScale;
uniform float time;
uniform vec2 windDirection;
uniform float windSpeed;
uniform float lod_metric;

float time2 = time * 0.001; //to seconds

void computeFoliageMovementTree(inout vec4 vertexData) {

	vec4 vertexM = gl_TextureMatrix[0] * gl_ModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);
	float move_speed = (float(int(vertexM.y*vertexM.z) % 50)/50.0 + 0.5);
	float timeTree = time2 * windSpeed * move_speed;
	float amplituted = pow(vertexData.y, 2.0);
	vertexData.x += 0.01 * amplituted * cos(timeTree + vertexM.x) *windDirection.x;
	vertexData.z += 0.05 *scale.y* amplituted * cos(timeTree + vertexM.z) *windDirection.y; ///wd.y is actually wd.z in code
}

void computeFoliageMovementGrass(in vec3 normalData, in vec3 normalMV, inout vec4 vertexData) {
	if(normalData.y < 0.0 ) {
		normalMV = -normalMV;
		float timeGrass = time2 * windSpeed;
		float cosX = cos(vertexData.x);
		float sinX = sin(vertexData.x);
		float halfScale = 0.5*grassScale;
		vertexData.x += (halfScale*cos(timeGrass) * cosX * sinX)*windDirection.x;
		vertexData.z += (halfScale*sin(timeGrass) * cosX * sinX)*windDirection.y;
	}
}

#endif
void main(void){

	computeData();
#if defined(ADD_FOLIAGE) && defined(IS_TREE)
	computeFoliageMovementTree(vertexData);
#endif

	computeLightVectors(false);
	//Compute the final vert position
	gl_Position = projectionMatrix * _vertexMV;
}


#version 130
/*“Copyright 2009-2013 DIVIDE-Studio”*/
#define MAX_LIGHT_COUNT 4
#define MAX_SHADOW_CASTING_LIGHTS 2
#extension GL_EXT_texture_array : enable
#extension GL_EXT_gpu_shader4 : enable
#line 6

uniform ivec2 screenDimension;
uniform float noise_tile;
uniform float noise_factor;
uniform float time;
uniform float water_shininess;

uniform sampler2D texWaterReflection;
uniform sampler2D texWaterNoiseNM;

varying vec3 vPixToLight;
varying vec3 vPixToEye;	
varying vec4 _vertexMV;
varying vec4 vVertexFromLightView;
varying vec2 _texCoord;

///Global NDotL, basically
float iDiffuse;

uniform bool enableFog;
const float LOG2 = 1.442695;
float zDepth = gl_FragCoord.z / gl_FragCoord.w;
vec4 applyFog(in vec4 color){
	if(enableFog){
		
		float fogFactor = exp2( -gl_Fog.density * 
				   			     gl_Fog.density * 
								 zDepth * 
								 zDepth * 
								 LOG2 );
		fogFactor = clamp(fogFactor, 0.0, 1.0);

		return mix(gl_Fog.color, color, fogFactor );
	}
	return color;
}

varying vec4 shadowCoord[MAX_SHADOW_CASTING_LIGHTS];
uniform bool enable_shadow_mapping;

uniform sampler2DArrayShadow texDepthMapFromLightArray;
uniform samplerCubeShadow    texDepthMapFromLightCube;
uniform sampler2DShadow texDepthMapFromLight0;
uniform sampler2DShadow texDepthMapFromLight1;
uniform sampler2DShadow texDepthMapFromLight2;
uniform sampler2DShadow texDepthMapFromLight3;
uniform sampler2D texDiffuseProjected;
uniform float    mixWeight;
////////////////////

uniform float lightBleedBias;


float linearStep(in float min, in float max, in float v){
  return clamp((v-min)/(max-min),0.0,1.0);
}  

void ReduceLightBleeding(inout float p_max)  {  
   p_max = linearStep(lightBleedBias, 1, p_max);  
}  

float chebyshevUpperBound( float distance){

	// We retrive the two moments previously stored (depth and depth*depth)
	//vec2 moments = texture(texDepthMapFromLightArray,posInDM.xyz).xy;
	vec2 moments;
		
	// Surface is fully lit. as the current fragment is before the light occluder
	if (distance <= moments.x)
		return 1.0 ;
	
	// The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check
	// How likely this pixel is to be lit (p_max)
	float variance = moments.y - (moments.x*moments.x);
	variance = max(variance,0.00002);
	
	float d = distance - moments.x;
	float p_max = variance / (variance + d*d);
	ReduceLightBleeding(p_max);
	return p_max;
}
	
float filterShadow(in sampler2DArrayShadow stex, in vec4 posInDM){
	float ret =  texture(stex, posInDM);
	if ((ret - 1) * ret * iDiffuse != 0) {
		ret *= 0.25;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1,-1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1, 0)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1, 1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 0,-1)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 0, 1)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1,-1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1, 0)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1, 1)).r * 0.0625;
	}
	return ret;
}

void applyShadowDirectional(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;
			
	// transform this fragment's position from view space to scaled light clip space
	// such that the xy coordinates are in [0;1]
	// note there is no need to divide by w for othogonal light sources
	vec4 shadow_coord = shadowCoord[_shadowIndex];
	
	// SHADOW MAPS
	vec3 vPixPosInDepthMap;
				
	float tOrtho[3];
	tOrtho[0] = 5.0;
	tOrtho[1] = 10.0;
	tOrtho[2] = 50.0;
	vec4 posInDM;
	for(int i = 0; i < 3; i++){
		vPixPosInDepthMap = vec3(shadow_coord.xy/tOrtho[i], shadow_coord.z) / shadow_coord.w;
		vPixPosInDepthMap = (vPixPosInDepthMap + 1.0) * 0.5;
		if(vPixPosInDepthMap.x >= 0.0 && vPixPosInDepthMap.y >= 0.0 && vPixPosInDepthMap.x <= 1.0 && vPixPosInDepthMap.y <= 1.0){
			posInDM.xy = vPixPosInDepthMap.xy;
			posInDM.w = vPixPosInDepthMap.z;
			posInDM.z = i;
			break; // no need to continue
		}
	}
	//shadow = chebyshevUpperBound(shadow_coord.w);
	shadow = filterShadow(texDepthMapFromLightArray, posInDM);

}


float filterFinalShadow(sampler2DShadow depthMap,vec3 vPosInDM){
	// Gaussian 3x3 filter
	float vDepthMapColor = texture(depthMap, vPosInDM);
	float fShadow = 0.0;
	float Z_TEST_SIGMA = 0.0001f;
	if((vDepthMapColor+Z_TEST_SIGMA) < vPosInDM.z){
		fShadow = vDepthMapColor * 0.25;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, -1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, 0)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, 1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 0, -1)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 0, 1)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, -1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, 0)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, 1)) * 0.0625;

		fShadow = clamp(fShadow, 0.0, 1.0);
	}else{
		fShadow = 1.0;
	}
	return fShadow;
}

void applyShadowSpot(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;

	// SHADOW MAPS
	vec3 vPixPosInDepthMap;

	vPixPosInDepthMap = shadowCoord[_shadowIndex].xyz/shadowCoord[_shadowIndex].w;
	vPixPosInDepthMap = (vPixPosInDepthMap + 1.0) * 0.5;	
	vec4 vDepthMapColor;
	switch(_shadowIndex){
		default:
		case 0:	shadow =  filterFinalShadow(texDepthMapFromLight0, vPixPosInDepthMap); break;
		case 1:	shadow =  filterFinalShadow(texDepthMapFromLight1, vPixPosInDepthMap); break;
		case 2: shadow =  filterFinalShadow(texDepthMapFromLight2, vPixPosInDepthMap); break;
		case 3: shadow =  filterFinalShadow(texDepthMapFromLight3, vPixPosInDepthMap); break;
	};
}


void applyShadowPoint(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;
	
	// SHADOW MAPS
	vec4 position_ls = gl_LightSource[_shadowIndex].position;
	vec4 abs_position = abs(position_ls);
	float fs_z = -max(abs_position.x, max(abs_position.y, abs_position.z));
	vec4 clip = shadowCoord[_shadowIndex] * vec4(0.0, 0.0, fs_z, 1.0);
	float depth = (clip.z / clip.w) * 0.5 + 0.5;
	shadow = texture(texDepthMapFromLightCube, vec4(position_ls.xyz, depth));
}


void projectTexture(in vec3 PoxPosInMap, inout vec4 texture){
	vec4 projectedTex = texture(texDiffuseProjected, vec2(PoxPosInMap.s, 1.0-PoxPosInMap.t));
	texture.xyz = mix(texture.xyz, projectedTex.xyz, mixWeight);
}


float Fresnel(vec3 incident, vec3 normal, float bias, float power);

void main (void)
{
	float time2 = time * 0.00001;
	vec2 uvNormal0 = _texCoord*noise_tile;
	uvNormal0.s += time2;
	uvNormal0.t += time2;
	vec2 uvNormal1 = _texCoord*noise_tile;
	uvNormal1.s -= time2;
	uvNormal1.t += time2;
		
	vec3 normal0 = texture(texWaterNoiseNM, uvNormal0).rgb * 2.0 - 1.0;
	vec3 normal1 = texture(texWaterNoiseNM, uvNormal1).rgb * 2.0 - 1.0;
	vec3 normal = normalize(normal0+normal1);
	
	vec2 uvReflection = vec2(gl_FragCoord.x/screenDimension.x, gl_FragCoord.y/screenDimension.y);
	vec2 uvFinal = uvReflection.xy + noise_factor*normal.xy;
	vec4 cDiffuse = texture(texWaterReflection, uvFinal);
	
	vec3 N = normalize(vec3(gl_ModelViewMatrix * vec4(normal.x, normal.z, normal.y, 0.0)));
	vec3 L = normalize(vPixToLight);
	vec3 V = normalize(vPixToEye);
	float iSpecular = pow(clamp(dot(reflect(-L, N), V), 0.0, 1.0), water_shininess);
	iDiffuse = max(dot(L, N), 0.0);
	//vec4 cAmbient = gl_LightSource[0].ambient * gl_FrontMaterial.ambient;
	vec4 cSpecular = gl_LightSource[0].specular * gl_FrontMaterial.specular * iSpecular;
	/////////////////////////
	// SHADOW MAPS
	float distance_max = 200.0;
	float shadow = 1.0;
	float distance = length(vPixToEye);
	if(distance < distance_max) {
		applyShadowDirectional(0, shadow);
	}
	/////////////////////////

	gl_FragColor = (0.2 + 0.8 * shadow) * cDiffuse + shadow * cSpecular;
	gl_FragColor = applyFog(gl_FragColor);
	// FRESNEL ALPHA
	gl_FragColor.a	= Fresnel(V, N, 0.5, 2.0);

}


float Fresnel(vec3 incident, vec3 normal, float bias, float power){
	float scale = 1.0 - bias;
	return bias + pow(1.0 - dot(incident, normal), power) * scale;
}


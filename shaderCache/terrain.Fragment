#version 130
/*“Copyright 2009-2013 DIVIDE-Studio”*/
#define MAX_LIGHT_COUNT 4
#define MAX_SHADOW_CASTING_LIGHTS 2
#extension GL_EXT_texture_array : enable
#extension GL_EXT_gpu_shader4 : enable
#define USE_VBO_DATA
#define DEFINE_PLACEHOLDER
#line 8

//based on: http://yannick.gerometta.free.fr/base.php?id=glsldemo
varying vec3 vPixToLightTBN[MAX_LIGHT_COUNT];
varying vec3 vPixToEyeTBN[MAX_LIGHT_COUNT];
varying vec4 shadowCoord[MAX_SHADOW_CASTING_LIGHTS];
varying vec3 vPixToLightMV[MAX_LIGHT_COUNT];

varying vec2 _texCoord;
varying vec3 _normalMV;
varying vec4 _vertexMV;

uniform sampler2D texDiffuseMap;
uniform sampler2D texNormalHeightMap;
uniform sampler2D texDiffuse0;
uniform sampler2D texDiffuse1;
uniform sampler2D texDiffuse2;
uniform sampler2D texDiffuse3;
uniform sampler2D texWaterCaustics;

uniform int LOD;
uniform int lightType[MAX_LIGHT_COUNT];
uniform float detail_scale;
uniform float diffuse_scale;
uniform float water_height;
uniform float time;
uniform bool water_reflection_rendering;
uniform bool alphaTexture;
uniform mat4 material;
uniform vec3 bbox_min;

#define LIGHT_DIRECTIONAL		0
#define LIGHT_OMNIDIRECTIONAL	1
#define LIGHT_SPOT				2

vec4 NormalMapping(vec2 uv, vec3 vPixToEyeTBN, vec3 vPixToLightTBN, bool underwater);
vec4 CausticsColor();

///Global NDotL, basically
float iDiffuse;

uniform bool  enableFog;
uniform float fogStart;
uniform float fogEnd;
uniform float fogDensitySqrtNeg;
uniform vec3  fogColor;

const float LOG2 = 1.442695;
float zDepth = gl_FragCoord.z / gl_FragCoord.w;

void applyFog(inout vec4 color){
	if(enableFog){
		
		float fogFactor = exp2( -gl_Fog.density * 
				   			     gl_Fog.density * 
								 zDepth * 
								 zDepth * 
								 LOG2 );
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		color = mix(gl_Fog.color, color, fogFactor );
	}
}

varying vec4 shadowCoord[MAX_SHADOW_CASTING_LIGHTS];
uniform bool enable_shadow_mapping;

uniform sampler2DArrayShadow texDepthMapFromLightArray;
uniform samplerCubeShadow    texDepthMapFromLightCube;
uniform sampler2DShadow texDepthMapFromLight0;
uniform sampler2DShadow texDepthMapFromLight1;
uniform sampler2DShadow texDepthMapFromLight2;
uniform sampler2DShadow texDepthMapFromLight3;
uniform sampler2D texDiffuseProjected;
uniform float    mixWeight;
////////////////////

uniform float lightBleedBias;


float linearStep(in float min, in float max, in float v){
  return clamp((v-min)/(max-min),0.0,1.0);
}  

void ReduceLightBleeding(inout float p_max)  {  
   p_max = linearStep(lightBleedBias, 1, p_max);  
}  

float chebyshevUpperBound( float distance){

	// We retrive the two moments previously stored (depth and depth*depth)
	//vec2 moments = texture(texDepthMapFromLightArray,posInDM.xyz).xy;
	vec2 moments;
		
	// Surface is fully lit. as the current fragment is before the light occluder
	if (distance <= moments.x)
		return 1.0 ;
	
	// The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check
	// How likely this pixel is to be lit (p_max)
	float variance = moments.y - (moments.x*moments.x);
	variance = max(variance,0.00002);
	
	float d = distance - moments.x;
	float p_max = variance / (variance + d*d);
	ReduceLightBleeding(p_max);
	return p_max;
}
	
float filterShadow(in sampler2DArrayShadow stex, in vec4 posInDM){
	float ret =  texture(stex, posInDM);
	if ((ret - 1) * ret * iDiffuse != 0) {
		ret *= 0.25;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1,-1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1, 0)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2(-1, 1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 0,-1)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 0, 1)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1,-1)).r * 0.0625;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1, 0)).r * 0.125;
		ret += shadow2DArrayOffset(stex, posInDM, ivec2( 1, 1)).r * 0.0625;
	}
	return ret;
}

void applyShadowDirectional(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;
			
	// transform this fragment's position from view space to scaled light clip space
	// such that the xy coordinates are in [0;1]
	// note there is no need to divide by w for othogonal light sources
	vec4 shadow_coord = shadowCoord[_shadowIndex];
	
	// SHADOW MAPS
	vec3 vPixPosInDepthMap;
				
	float tOrtho[3];
	tOrtho[0] = 5.0;
	tOrtho[1] = 10.0;
	tOrtho[2] = 50.0;
	vec4 posInDM;
	for(int i = 0; i < 3; i++){
		vPixPosInDepthMap = vec3(shadow_coord.xy/tOrtho[i], shadow_coord.z) / shadow_coord.w;
		vPixPosInDepthMap = (vPixPosInDepthMap + 1.0) * 0.5;
		if(vPixPosInDepthMap.x >= 0.0 && vPixPosInDepthMap.y >= 0.0 && vPixPosInDepthMap.x <= 1.0 && vPixPosInDepthMap.y <= 1.0){
			posInDM.xy = vPixPosInDepthMap.xy;
			posInDM.w = vPixPosInDepthMap.z;
			posInDM.z = i;
			break; // no need to continue
		}
	}
	//shadow = chebyshevUpperBound(shadow_coord.w);
	shadow = filterShadow(texDepthMapFromLightArray, posInDM);

}


float filterFinalShadow(sampler2DShadow depthMap,vec3 vPosInDM){
	// Gaussian 3x3 filter
	float vDepthMapColor = texture(depthMap, vPosInDM);
	float fShadow = 0.0;
	float Z_TEST_SIGMA = 0.0001f;
	if((vDepthMapColor+Z_TEST_SIGMA) < vPosInDM.z){
		fShadow = vDepthMapColor * 0.25;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, -1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, 0)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( -1, 1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 0, -1)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 0, 1)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, -1)) * 0.0625;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, 0)) * 0.125;
		fShadow += textureOffset(depthMap, vPosInDM, ivec2( 1, 1)) * 0.0625;

		fShadow = clamp(fShadow, 0.0, 1.0);
	}else{
		fShadow = 1.0;
	}
	return fShadow;
}

void applyShadowSpot(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;

	// SHADOW MAPS
	vec3 vPixPosInDepthMap;

	vPixPosInDepthMap = shadowCoord[_shadowIndex].xyz/shadowCoord[_shadowIndex].w;
	vPixPosInDepthMap = (vPixPosInDepthMap + 1.0) * 0.5;	
	vec4 vDepthMapColor;
	switch(_shadowIndex){
		default:
		case 0:	shadow =  filterFinalShadow(texDepthMapFromLight0, vPixPosInDepthMap); break;
		case 1:	shadow =  filterFinalShadow(texDepthMapFromLight1, vPixPosInDepthMap); break;
		case 2: shadow =  filterFinalShadow(texDepthMapFromLight2, vPixPosInDepthMap); break;
		case 3: shadow =  filterFinalShadow(texDepthMapFromLight3, vPixPosInDepthMap); break;
	};
}


void applyShadowPoint(in int _shadowIndex, inout float shadow) {
	///Limit maximum number of lights that cast shadows
	if(!enable_shadow_mapping) return;
	
	// SHADOW MAPS
	vec4 position_ls = gl_LightSource[_shadowIndex].position;
	vec4 abs_position = abs(position_ls);
	float fs_z = -max(abs_position.x, max(abs_position.y, abs_position.z));
	vec4 clip = shadowCoord[_shadowIndex] * vec4(0.0, 0.0, fs_z, 1.0);
	float depth = (clip.z / clip.w) * 0.5 + 0.5;
	shadow = texture(texDepthMapFromLightCube, vec4(position_ls.xyz, depth));
}


void projectTexture(in vec3 PoxPosInMap, inout vec4 texture){
	vec4 projectedTex = texture(texDiffuseProjected, vec2(PoxPosInMap.s, 1.0-PoxPosInMap.t));
	texture.xyz = mix(texture.xyz, projectedTex.xyz, mixWeight);
}


bool isUnderWater(){
	return _vertexMV.y < water_height;
}

void main (void)
{
	// Discard the fragments that are underwater when drawing in reflection
	bool underwater = isUnderWater();
	if(water_reflection_rendering && underwater){
		discard;
	}
	
	vec4 color = NormalMapping(_texCoord, vPixToEyeTBN[0], vPixToLightTBN[0], underwater);
	
	if(underwater) {
		float alpha = (water_height - _vertexMV.y) / (2*(water_height - bbox_min.y));
		color = (1-alpha) * color + alpha * CausticsColor();
	}
    applyFog(color);

	gl_FragData[0] = color;
}

vec4 CausticsColor()
{
	float time2 = time * 0.000001;
	vec2 uv0 = _texCoord*100.0;
	uv0.s -= time2;
	uv0.t += time2;
	vec4 color0 = texture(texWaterCaustics, uv0);
	
	vec2 uv1 = _texCoord*100.0;
	uv1.s += time2;
	uv1.t += time2;	
	vec4 color1 = texture(texWaterCaustics, uv1);
	
	return (color0 + color1) /2;	
}

vec4 NormalMapping(vec2 uv, vec3 vPixToEyeTBN, vec3 vPixToLightTBN, bool underwater)
{	
	vec3 lightVecTBN = normalize(vPixToLightTBN);
	vec3 viewVecTBN = normalize(vPixToEyeTBN);

	vec2 uv_detail = uv * detail_scale;
	vec2 uv_diffuse = uv * diffuse_scale/* / LOD*/;

	
	vec3 normalTBN = texture(texNormalHeightMap, uv_detail).rgb * 2.0 - 1.0;
	normalTBN = normalize(normalTBN);
	
	vec4 tBase[4];

	tBase[0] = texture(texDiffuse0, uv_diffuse);
	tBase[1] = texture(texDiffuse1, uv_diffuse);	
	tBase[2] = texture(texDiffuse2, uv_diffuse);
	tBase[3] = texture(texDiffuse3, uv_diffuse);
	
	vec4 DiffuseMap = texture(texDiffuseMap, uv);
	
	vec4 cBase;

	if(_vertexMV.y < water_height)
		cBase = tBase[0];
	else {
		if(alphaTexture){
			cBase = mix(mix(mix(tBase[1], tBase[0], DiffuseMap.r), tBase[2], DiffuseMap.g), tBase[3], DiffuseMap.a);
		}else{
			cBase = mix(mix(tBase[1], tBase[0], DiffuseMap.r), tBase[2], DiffuseMap.g);			
		}
	}

	// SHADOW MAPS
	float distance_max = 200.0;
	float shadow = 1.0;
	float distance = length(vPixToEyeTBN);
	if(distance < distance_max) {
		applyShadowDirectional(0, shadow);
		shadow = 1.0 - (1.0-shadow) * (distance_max-distance) / distance_max;
	}

	iDiffuse = max(dot(lightVecTBN.xyz, normalTBN), 0.0);	// diffuse intensity. NDotL

	vec4 cAmbient = gl_LightSource[0].ambient * material[0] + gl_LightModel.ambient * material[0];
	vec4 cDiffuse = gl_LightSource[0].diffuse * material[1] * iDiffuse * shadow;	
	vec4 cSpecular = 0;
	if(underwater){
		///Add specular intensity
		cSpecular =  gl_LightSource[0].specular * material[2];
		cSpecular *= pow(clamp(dot(reflect(-lightVecTBN.xyz, normalTBN), viewVecTBN), 0.0, 1.0), material[3].x )/2.0;
		cSpecular *= shadow;
	}

	return cAmbient * cBase +  cDiffuse * cBase + cSpecular;
}

#ifndef _NODE_DATA_DEFINITION_CMN_
#define _NODE_DATA_DEFINITION_CMN_

#include "nodeDataInput.cmn"

#define TRANSFORM_IDX VAR._indirectionIDs.x
#define MATERIAL_IDX VAR._indirectionIDs.y
#define TEXTURE_IDX VAR._indirectionIDs.z

struct NodeTransformData {
    mat4 _worldMatrix;
    mat4 _prevWorldMatrix;
    //[0][0]...[2][2] - normalMatrix
    //[0][3] = 4x8U: reserverd, animation ticked this frame (for motion blur), LoDLevel, occlusion cull
    //[1][3] = selectionFlag
    //[2][3] = boneCount
    //[3][0..3] = boundingSphere
    mat4 _normalMatrixW;
};

#define NodeIndirectionData uvec4
#define _transformIdx x
#define _materialIdx y
#define _texturesIdx z

#if defined(PROJECTED_TEXTURE)
uniform float projectedTextureMixWeight;
#endif //PROJECTED_TEXTURE

#if defined(FRAG_SHADER) || defined(NEED_MATERIAL_DATA)

struct NodeMaterialData
{
    //base colour
    vec4 _albedo;
    //rgb - emissive
    //a   - parallax factor
    vec4 _emissiveAndParallax;
    //rgb - ambientColour (Don't really need this. To remove eventually, but since we have the space, might as well)
    //a - specular strength [0...Material::MAX_SHININESS]. Used mainly by Phong shading
    vec4 _colourData;
    //x = 4x8U: occlusion, metallic, roughness, reserved
    //y = 4x8U: specularR, specularG, specularB, isDoubleSided
    //z = 4x8U: reserved, shadingMode, use packed OMR, bump method
    //w = Probe lookup index + 1 (0 = sky cubemap)
    uvec4 _data;
    //x = 4x8U: tex op Unit0, tex op Unit1, tex op Specular, Emissive
    //y = 4x8U: tex op Occlusion, tex op Metalness, tex op Roughness, tex op Opcaity
    //z = 4x8U: use albedo texture alpha channel, use opacity map alpha channel, specular Factor, gloss Factor
    //w = 4x8u: receives shadows, reserved, reserved, reserved
    uvec4 _textureOperations;
};

#define BaseColour(materialData) materialData._albedo
#define EmissiveColour(materialData) materialData._emissiveAndParallax.rgb
#define Specular(materialData) unpackUnorm4x8(materialData._data.y).rgb
#define Ambient(materialData) materialData._colourData.rgb
#define SpecularStrength(materialData) materialData._colourData.a

#define dvd_probeIndex(materialData) materialData._data.w
#define dvd_texOperationsA(materialData) uvec4(unpackUnorm4x8(materialData._textureOperations.x) * 255)
#define dvd_texOperationsB(materialData) uvec4(unpackUnorm4x8(materialData._textureOperations.y) * 255)
#define dvd_TexOpUnit0(materialData) dvd_texOperationsA(materialData).x
#define dvd_TexOpSpecular(materialData) dvd_texOperationsA(materialData).z
#define dvd_TexOpEmissive(materialData) dvd_texOperationsA(materialData).w
#define dvd_TexOpOpacity(materialData)  dvd_texOperationsB(materialData).w

#define dvd_bumpMethod(X) uint(unpackUnorm4x8(dvd_Materials[X]._data.z).w * 255)

#define dvd_useAlbedoTextureAlphaChannel(materialData) (uint(unpackUnorm4x8(materialData._textureOperations.z).x) == 1u)

#define dvd_useOpacityAlphaChannel(materialData) (uint(unpackUnorm4x8(materialData._textureOperations.z).y) == 1u)

#define dvd_receivesShadows(materialData) (uint(unpackUnorm4x8(materialData._textureOperations.w).x) == 1u)

#define dvd_specularGloss(materialData) unpackUnorm4x8(materialData._textureOperations.z).zw

#define dvd_parallaxFactor(X) dvd_Materials[X]._emissiveAndParallax.a

#define dvd_isDoubleSided(materialData) (uint(unpackUnorm4x8(materialData._data.y).a * 255) == 1u)

#endif //FRAG_SHADER || NEED_MATERIAL_DATA

#define dvd_WorldMatrix(transformData) transformData._worldMatrix

#define dvd_normalMatrixW(transformData) mat3(transformData._normalMatrixW)

#define dvd_nodeData(transformData) unpackUnorm4x8(uint(transformData._normalMatrixW[0][3]))

#define dvd_frameTicked(transformData) (uint(dvd_nodeData(transformData).y  * 255) == 1u)

#define dvd_LoDLevel(transformData) uint(dvd_nodeData(transformData).z * 255)

#define dvd_cullNode(transformData) (uint(dvd_nodeData(transformData).w * 255) == 1u)

#define dvd_selectionFlag(transformData) (transformData._normalMatrixW[1][3])

#define dvd_boneCount(transformData) uint(transformData._normalMatrixW[2][3])

#define dvd_boundingSphere(transformData) transformData._normalMatrixW[3]
#endif //_NODE_DATA_DEFINITION_CMN_

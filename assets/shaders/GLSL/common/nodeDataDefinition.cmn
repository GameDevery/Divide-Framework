#ifndef _NODE_DATA_DEFINITION_CMN_
#define _NODE_DATA_DEFINITION_CMN_

#define TRANSFORM_IDX VAR._indirectionIDs.x
#define MATERIAL_IDX VAR._indirectionIDs.y
#define TEXTURE_IDX VAR._indirectionIDs.z

struct NodeTransformData {
    mat4 _worldMatrix;
    mat4 _prevWorldMatrix;

    // [0...2][0...2] = normal matrix
    // [3][0...2]     = bounds center
    // [3][3]         = Data Flag
    // [0][3]         = 4x8U: bone count, LoDLevel, animation ticked this frame (for motion blur), occlusion cull
    // [1][3]         = 2x16F: BBox HalfExtent (X, Y) 
    // [2][3]         = 2x16F: BBox HalfExtent (Z), BSphere Radius
    mat4 _normalMatrixW;
};

#define NodeIndirectionData uvec4
#define _transformIdx x
#define _materialIdx y
#define _texturesIdx z

#if defined(PROJECTED_TEXTURE)
uniform float projectedTextureMixWeight;
#endif //PROJECTED_TEXTURE

#if defined(FRAG_SHADER) || defined(NEED_MATERIAL_DATA)

struct NodeMaterialData
{
    //base colour
    vec4 _albedo;
    //rgb - emissive
    //a   - parallax factor
    vec4 _emissiveAndParallax;
    //rgb - ambientColour (Don't really need this. To remove eventually, but since we have the space, might as well)
    //a - specular strength [0...1000]. Used mainly by Phong shading
    vec4 _colourData;
    //x = 4x8U: occlusion, metallic, roughness, selection flag (1 == hovered, 2 == selected)
    //y = 4x8U: specularR, specularG, specularB, isDoubleSided
    //z = 4x8U: reserved, shadingMode, use packed OMR, bump method
    //w = Probe lookup index + 1 (0 = sky cubemap)
    uvec4 _data;
    //x = 4x8U: tex op Unit0, tex op Unit1, tex op Specular, Emissive
    //y = 4x8U: tex op Occlusion, tex op Metalness, tex op Roughness, tex op Opcaity
    //z = 4x8U: use albedo texture alpha channel, use opacity map alpha channel, reserved, reserved
    //w = reserved
    uvec4 _textureOperations;
};

struct PBRMaterial
{
    vec4  _specular;
    vec3  _diffuseColour;
    vec3 _F0;
    vec3  _emissive;
    float _a;
    float _occlusion;
    float _metallic;
    float _roughness;
    uint _shadingMode;
};

#define BaseColour(materialData) materialData._albedo
#define EmissiveColour(materialData) materialData._emissiveAndParallax.rgb
#define Specular(materialData) unpackUnorm4x8(materialData._data.y).rgb
#define Ambient(materialData) materialData._colourData.rgb
#define SpecularStrength(materialData) materialData._colourData.a

#define dvd_probeIndex(materialData) materialData._data.w
#define dvd_texOperationsA(materialData) uvec4(unpackUnorm4x8(materialData._textureOperations.x) * 255)
#define dvd_texOperationsB(materialData) uvec4(unpackUnorm4x8(materialData._textureOperations.y) * 255)
#define dvd_TexOpUnit0(materialData) dvd_texOperationsA(materialData).x
#define dvd_TexOpSpecular(materialData) dvd_texOperationsA(materialData).z
#define dvd_TexOpEmissive(materialData) dvd_texOperationsA(materialData).w
#define dvd_TexOpOpacity(materialData)  dvd_texOperationsB(materialData).w

#define dvd_bumpMethod(X) uint(unpackUnorm4x8(dvd_Materials[X]._data.z).w * 255)

#define dvd_useAlbedoTextureAlphaChannel(materialData) (uint(unpackUnorm4x8(materialData._textureOperations.z).x * 255) == 1u)

#define dvd_useOpacityAlphaChannel(materialData) (uint(unpackUnorm4x8(materialData._textureOperations.z).y * 255) == 1u)

#define dvd_parallaxFactor(X) dvd_Materials[X]._emissiveAndParallax.a

#define dvd_isDoubleSided(materialData) (uint(unpackUnorm4x8(materialData._data.y).a * 255) == 1u)

#endif //FRAG_SHADER || NEED_MATERIAL_DATA

#define dvd_WorldMatrix dvd_Transforms[TRANSFORM_IDX]._worldMatrix

#define dvd_NormalMatrixW(transformData) mat3(transformData._normalMatrixW)

#define dvd_boneCount(transformData) uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).x * 255)

#define dvd_LoDLevel(transformData) uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).y * 255)

#define dvd_frameTicked(transformData) (uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).z  * 255) == 1u)

#define dvd_cullNode(transformData) (uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).w * 255) == 1u)

#define dvd_dataFlag dvd_Transforms[TRANSFORM_IDX]._normalMatrixW[3][3]

#endif //_NODE_DATA_DEFINITION_CMN_

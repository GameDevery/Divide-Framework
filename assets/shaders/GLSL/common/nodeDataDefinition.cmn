#ifndef _NODE_DATA_DEFINITION_CMN_
#define _NODE_DATA_DEFINITION_CMN_

#if defined(SAMPLER_UNIT0_IS_ARRAY)
#define samplerUnit0 sampler2DArray
#else
#define samplerUnit0 sampler2D
#endif
#if defined(SAMPLER_OPACITY_IS_ARRAY)
#define samplerOpacity sampler2DArray
#else
#define samplerOpacity sampler2D
#endif
#if defined(SAMPLER_UNIT1_IS_ARRAY)
#define samplerUnit1 sampler2DArray
#else
#define samplerUnit1 sampler2D
#endif
#if defined(SAMPLER_OCCLUSION_METALLIC_ROUGHNESS_IS_ARRAY)
#define samplerOMR sampler2DArray
#else
#define samplerOMR sampler2D
#endif
#if defined(SAMPLER_HEIGHTMAP_IS_ARRAY)
#define samplerHeight sampler2DArray
#else
#define samplerHeight sampler2D
#endif
#if defined(SAMPLER_PROJECTION_IS_ARRAY)
#define samplerProj sampler2DArray
#else
#define samplerProj sampler2D
#endif
#if defined(SAMPLER_NORMALMAP_IS_ARRAY)
#define samplerNormal sampler2DArray
#else
#define samplerNormal sampler2D
#endif

struct NodeTransformData {
    mat4 _worldMatrix;

    // [0...2][0...2] = normal matrix
    // [3][0...2]     = bounds center
    // [0][3]         = 4x8U: bone count, lod level, isHovered, reserved
    // [1][3]         = 2x16F: BBox HalfExtent (X, Y) 
    // [2][3]         = 2x16F: BBox HalfExtent (Z), BSphere Radius
    // [3][3]         = 2x16F: (Data Flag, reserved)
    mat4 _normalMatrixW;

    // [0...3][0...2] = previous world matrix
    // [0][3]         = 4x8U: animation ticked this frame (for motion blur), occlusion cull, reserved, reserved
    // [1][3]         = reserved
    // [2][3]         = reserved
    // [3][3]         = reserved
    mat4 _prevWorldMatrix;


};

struct NodeMaterialData
{
    // [0][0...3] = base colour
    // [1][0...2] = emissive
    // [1][3]     = parallax factor
    // [2][0]     = 4x8U: occlusion, metallic, roughness, reserved
    // [2][1]     = IBL texture size
    // [2][2]     = 4x8U: tex op, bump method, reserved, reserved
    // [2][3]     = reserved
    // [3][0]     = reserved
    // [3][1]     = reserved
    // [3][2]     = reserved
    // [3][3]     = reserved
    mat4 _colourMatrix;

#if defined(USE_BINDLESS_TEXTURES)
    samplerUnit0 _texDiffuse0;
    samplerOpacity _texOpacityMap;
    samplerUnit1 _texDiffuse1;
    samplerOMR _texOcclusionMetallicRoughness;
    samplerHeight _texHeight;
    samplerProj _texProjected;
    samplerNormal _texNormalMap;
    float _padding[2];
#else
    vec4 _padding[4];
#endif //USE_BINDLESS_TEXTURES
};

#define PACKED_OMR(colourMat) unpackUnorm4x8(uint(colourMat[1][0]))

#define BaseColour(colourMat) colourMat[0].rgba

#define EmissiveColour(colourMat) colourMat[1].rgb

#define Occlusion(colourMat) PACKED_OMR(colourMat).r

#define Metallic(colourMat) PACKED_OMR(colourMat).g

#define Roughness(colourMat) PACKED_OMR(colourMat).b

#define IBLSize(colourMat) uint(colourMat[2][1])


#define NormalMatrixW(transformData) mat3(transformData._normalMatrixW)

#define dvd_boneCount(transformData) uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).x * 255)

#define dvd_lodLevel(transformData)  uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).y * 255)

#define dvd_isHovered(transformData) (uint(unpackUnorm4x8(uint(transformData._normalMatrixW[0][3])).z * 255) == 1)

#define dvd_dataFlag(X) unpackHalf2x16(uint(dvd_Transforms[X]._normalMatrixW[3][3])).x

#define dvd_frameTicked(transformData) (uint(unpackUnorm4x8(uint(transformData._prevWorldMatrix[0][3])).x  * 255) == 1)

#define dvd_cullNode(transformData) (uint(unpackUnorm4x8(uint(transformData._prevWorldMatrix[0][3])).y * 255) == 1)

#define dvd_texOperation(materialData) uint(unpackUnorm4x8(uint(materialData._colourMatrix[2][2])).x * 255)

#define dvd_bumpMethod(materialData)  uint(unpackUnorm4x8(uint(materialData._colourMatrix[2][2])).y * 255)

#define dvd_parallaxFactor(X)  dvd_Materials[X]._colourMatrix[1][3]

#endif //_NODE_DATA_DEFINITION_CMN_

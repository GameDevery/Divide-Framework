#ifndef _NODE_DATA_INPUT_CMN_
#define _NODE_DATA_INPUT_CMN_

#include "utility.cmn"

#if defined(PRE_PASS) || defined(SHADOW_PASS)
#   define DEPTH_PASS
#endif

#if defined(GEOM_SHADER)
#define InBlock gl_in[];
#else //GEOM_SHADER
#define InBlock gl_in[gl_MaxPatchVertices];
#endif //GEOM_SHADER

#if defined(TESS_CTRL_SHADER)
#define OutBlock gl_out[];
#else //TESS_CTRL_SHADER
#define OutBlock ;
#endif //TESS_CTRL_SHADER

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

#if defined(GEOM_SHADER) || defined(TESS_CTRL_SHADER) || defined(TESS_EVAL_SHADER)
in gl_PerVertex
{
  vec4  gl_Position;
  float gl_PointSize;
#if !defined(NO_CLIP_CULL_IN)
  float gl_ClipDistance[MAX_CLIP_PLANES];
  float gl_CullDistance[MAX_CULL_DISTANCES];
#endif //!NO_CLIP_CULL_IN
} InBlock
#endif //GEOM_SHADER || TESS_CTRL_SHADER || TESS_EVAL_SHADER

out gl_PerVertex
{
  invariant vec4 gl_Position;
  float gl_PointSize;
#if !defined(NO_CLIP_CULL_OUT)
  float gl_ClipDistance[MAX_CLIP_PLANES];
  float gl_CullDistance[MAX_CULL_DISTANCES];
#endif //!NO_CLIP_CULL_OUT
} OutBlock

#endif //!COMPUTE_SHADER && !FRAG_SHADER

#define SHADOW_PASS_NORMAL 0
#define SHADOW_PASS_ORTHO 1
#define SHADOW_PASS_CUBE 2

layout(binding = BUFFER_RENDER_BLOCK, std140) uniform dvd_RenderBlock
{
    mat4  dvd_PreviousViewMatrix;
    mat4  dvd_PreviousProjectionMatrix;
    //x - elapsed time (ms)
    vec4  dvd_renderProperties;
    //x - cluster size X, y - cluster size Y
    vec4  dvd_lightingProperties;
    //x - material debug flag, y - fog enabled, z - clip plane count, w - reserved
    vec4  dvd_otherProperties;

    vec4  dvd_clipPlanes[MAX_CLIP_PLANES];
    vec4 _render_padding[2];
};

#define dvd_time int(dvd_renderProperties.x)
#define dvd_materialDebugFlag int(dvd_otherProperties.x)
#define dvd_ClipPlaneCount int(dvd_otherProperties.z)
#define dvd_ClusterSizes dvd_lightingProperties.xy

#if !defined(NO_CAM_BLOCK)
layout(binding = BUFFER_CAM_BLOCK, std140) uniform dvd_CamBlock
{
    mat4  dvd_ProjectionMatrix;
    mat4  dvd_InverseProjectionMatrix;
    mat4  dvd_ViewMatrix;
    mat4  dvd_InverseViewMatrix;
    mat4  dvd_ViewProjectionMatrix;
    //xyz - position, w - aspect ratio
    vec4  dvd_cameraPosition; 
    vec4  dvd_ViewPort;
    //x - scale, y - bias
    vec4 dvd_lightingTweakValues;
    //x - nearPlane, y - farPlane, z - FoV, w - ortho camera
    vec4  dvd_camProperties;
    vec4  dvd_frustumPlanes[6];
    vec4 _cam_padding[2];
};

#define dvd_fogEnabled (int(dvd_otherProperties.y) == 1)
#define SHADOW_PASS_TYPE int(dvd_camProperties.w)
#define CAMERA_FLAG SHADOW_PASS_TYPE

#define dvd_cameraForward vec3(dvd_ViewMatrix[3].xyz)
#define windowWidth int(dvd_ViewPort.z)
#define windowHeight int(dvd_ViewPort.w)

#define dvd_screenDimensions dvd_ViewPort.zw
#define dvd_invScreenDimensions (1.f / dvd_screenDimensions)
#define dvd_aspectRatio dvd_cameraPosition.w
#define dvd_zPlanes dvd_camProperties.xy
#define dvd_fieldOfView dvd_camProperties.z

#define dvd_LightScale dvd_lightingTweakValues.x
#define dvd_LightBias dvd_lightingTweakValues.y
#define dvd_IsOrthoCamera  (uint(dvd_camProperties.w) == 1u)

#endif //!NO_CAM_BLOCK

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

#if defined(TESS_CTRL_SHADER)
#if !defined(NO_CLIP_CULL_OUT)
#define CLIP_OUTPUT(X) gl_out[gl_InvocationID].gl_ClipDistance[X]
#endif //!NO_CLIP_CULL_OUT
#define OUT _out[gl_InvocationID]
#else
#if !defined(NO_CLIP_CULL_OUT)
#define CLIP_OUTPUT(X) gl_ClipDistance[X]
#endif //!NO_CLIP_CULL_OUT
#define OUT _out
#endif

#if !defined(NO_CLIP_CULL_OUT)
#define CLIP_INDEX(X) CLIP_OUTPUT(X) = (dvd_ClipPlaneCount > X) ? dot(OUT._vertexW, dvd_clipPlanes[X]) : 0.f

#if MAX_CLIP_PLANES == 1
#define setClipPlanes() \
    CLIP_INDEX(0);
#elif MAX_CLIP_PLANES == 2
#define setClipPlanes() \
    CLIP_INDEX(0);      \
    CLIP_INDEX(1);
#elif MAX_CLIP_PLANES == 3
#define setClipPlanes() \
    CLIP_INDEX(0);      \
    CLIP_INDEX(1);      \
    CLIP_INDEX(2);
#elif MAX_CLIP_PLANES == 4
#define setClipPlanes() \
    CLIP_INDEX(0);      \
    CLIP_INDEX(1);      \
    CLIP_INDEX(2);      \
    CLIP_INDEX(3);
#elif MAX_CLIP_PLANES == 5
#define setClipPlanes() \
    CLIP_INDEX(0);      \
    CLIP_INDEX(1);      \
    CLIP_INDEX(2);      \
    CLIP_INDEX(3);      \
    CLIP_INDEX(4);
#else 
#define setClipPlanes() \
    CLIP_INDEX(0);      \
    CLIP_INDEX(1);      \
    CLIP_INDEX(2);      \
    CLIP_INDEX(3);      \
    CLIP_INDEX(4);      \
    CLIP_INDEX(5);
#endif //MAX_CLIP_PLANES
#endif //!NO_CLIP_CULL_OUT
#endif //!COMPUTE_SHADER && !FRAG_SHADER

#define BitCompare(MASK, BIT) ((MASK & BIT) != 0)

#endif //_NODE_DATA_INPUT_CMN_

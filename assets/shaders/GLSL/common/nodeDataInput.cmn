#ifndef _NODE_DATA_INPUT_CMN_
#define _NODE_DATA_INPUT_CMN_

vec4 positionFromDepth(in float depth,
                       in mat4 invProjectionMatrix,
                       in vec2 uv) {

    vec4 pos = vec4(2.0 * uv.x - 1.0,
        2.0 * uv.y - 1.0,
        2.0 * depth - 1.0,
        1.0);

    pos = invProjectionMatrix * pos;
    pos /= pos.w;

    return pos;
}

vec3 UNPACK_FLOAT(in float value) {
    return (fract(vec3(1.0, 256.0, 65536.0) * value)* 2.0) - 1.0;
}

#if defined(COMPUTE_SHADER)
struct IndirectDrawCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

layout(binding = BUFFER_GPU_COMMANDS, std430) coherent buffer dvd_GPUCmds
{
    IndirectDrawCommand dvd_drawCommands[MAX_VISIBLE_NODES];
};
#endif

// This could be split up in the future into frequent-infrequent blocks depending on update rate
layout(binding = BUFFER_GPU_BLOCK, std140) uniform dvd_GPUBlock
{
    mat4  dvd_ProjectionMatrix;
    mat4  dvd_InvProjectionMatrix;
    mat4  dvd_ViewMatrix;
    mat4  dvd_ViewProjectionMatrix;
    ///xyz - position, w - aspect ratio
    vec4  dvd_cameraPosition; 
    //x - nearPlane, y - farPlane, z - FoV, w - reserved
    vec4  dvd_renderProperties;
    vec4  dvd_ViewPort;
    vec4  dvd_frustumPlanes[MAX_CLIP_PLANES];
    vec4  dvd_clip_plane[MAX_CLIP_PLANES];
};

vec2 dvd_invScreenDimensions() {
    return dvd_ViewPort.zw * 0.5;
}

#define dvd_zPlanes vec2(dvd_renderProperties.xy)
#define dvd_aspectRatio dvd_cameraPosition.w
#define dvd_fieldOfView dvd_renderProperties.z

struct WaterBodyData {
    vec4 positionW;
    vec4 details;
};

layout(binding = BUFFER_SCENE_DATA, std430) coherent readonly buffer dvd_SceneData
{
    // x,y,z - colour, w - density
    vec4   dvd_fogDetails;
    // x,y,z - direction, w - speed
    vec4   dvd_windDetails;
    //x - light bleed bias, y - min shadow variance, z - fade distance, w - max distance
    vec4   dvd_shadowingSettings;
    //x - elapsed time, y - delta time, z - reserved, w - packed: w.x - debug render, w.y - detail level, w.z - reserved
    vec4   dvd_otherData;
    WaterBodyData dvd_waterEntities[];
};

#define dvd_fogColour dvd_fogDetails.xyz
#define dvd_fogDensity dvd_fogDetails.w
#define dvd_time int(dvd_otherData.x)
#define dvd_deltaTime (int(dvd_otherData.y))
#define dvd_showDebugInfo (uint(UNPACK_FLOAT(dvd_otherData.w).x))
#define dvd_renderDetailLevel (uint(UNPACK_FLOAT(dvd_otherData.w).y * DETAIL_COUNT))

bool IsUnderWater(vec3 positionWorld) {
    for (int i = 0; i < dvd_waterEntities.length(); ++i) {
        WaterBodyData data = dvd_waterEntities[i];
        vec4 details = data.details;
        vec4 position = data.positionW;
        float waterWidth = details.x + position.x;
        float waterLength = details.y + position.z;
        float halfWidth = waterWidth * 0.5;
        float halfLength = waterLength * 0.5;
        if (positionWorld.x >= -halfWidth && positionWorld.x <= halfWidth &&
            positionWorld.z >= -halfLength && positionWorld.z <= halfLength)
        {
            float height = position.y;
            float depth = -details.y + height;
            if (positionWorld.y < height && positionWorld.y > depth) {
                return true;
            }
        }
    }

    return false;
}

#if defined(VERT_SHADER) || defined(GEOM_SHADER)
out gl_PerVertex
{
  invariant vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[MAX_CLIP_PLANES];
};

void setClipPlanes(in vec4 worldSpaceVertex) {
    for(int i = 0; i < MAX_CLIP_PLANES; ++i) {
        gl_ClipDistance[i] = dot(worldSpaceVertex, dvd_clip_plane[i]);
    }
}
#endif

//mix(false, true, condition);

#endif //_NODE_DATA_INPUT_CMN_
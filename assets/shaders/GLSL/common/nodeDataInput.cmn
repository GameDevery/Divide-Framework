#ifndef _NODE_DATA_INPUT_CMN_
#define _NODE_DATA_INPUT_CMN_

#include "utility.cmn"

#if defined(PRE_PASS) || defined(SHADOW_PASS)
#   define DEPTH_PASS
#endif

#if defined(GEOM_SHADER)
#define InBlock gl_in[];
#else //GEOM_SHADER
#define InBlock gl_in[gl_MaxPatchVertices];
#endif //GEOM_SHADER

#if defined(TESS_CTRL_SHADER)
#define OutBlock gl_out[];
#else //TESS_CTRL_SHADER
#define OutBlock ;
#endif //TESS_CTRL_SHADER

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

#if defined(GEOM_SHADER) || defined(TESS_CTRL_SHADER) || defined(TESS_EVAL_SHADER)
in gl_PerVertex
{
  vec4  gl_Position;
  float gl_PointSize;
#if defined(HAS_CLIPPING_IN)
  float gl_ClipDistance[MAX_CLIP_PLANES];
#endif
#if defined(HAS_CULLING_IN)
  float gl_CullDistance[MAX_CULL_DISTANCES];
#endif
} InBlock
#endif

out gl_PerVertex
{
  invariant vec4 gl_Position;
  float gl_PointSize;
#if defined(HAS_CLIPPING_OUT)
  float gl_ClipDistance[MAX_CLIP_PLANES];
#endif
#if defined(HAS_CULLING_OUT)
  float gl_CullDistance[MAX_CULL_DISTANCES];
#endif
} OutBlock

#endif //!defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

// This could be split up in the future into frequent-infrequent blocks depending on update rate
layout(binding = BUFFER_GPU_BLOCK, std140) uniform dvd_GPUBlock
{
    mat4  dvd_ProjectionMatrix;
    mat4  dvd_InverseProjectionMatrix;
    mat4  dvd_ViewMatrix;
    mat4  dvd_InverseViewMatrix;
    mat4  dvd_ViewProjectionMatrix;
    mat4  dvd_PreviousViewProjectionMatrix;
    ///xyz - position, w - aspect ratio
    vec4  dvd_cameraPosition; 
    vec4  dvd_ViewPort;
    //x - nearPlane, y - farPlane, z - FoV, w - elapsed time (ms)
    vec4  dvd_renderProperties;
    //x - cluster size X, y - cluster size Y, z - scale, w - bias
    vec4  dvd_lightingProperties;
    //x - material debug flag, y - reserved, z - camera flag, w - clip plane count
    vec4  dvd_otherProperties;
    vec4  dvd_frustumPlanes[6];
    vec4  dvd_clipPlanes[MAX_CLIP_PLANES];
};

#define SHADOW_PASS_NORMAL 0
#define SHADOW_PASS_ORTHO 1
#define SHADOW_PASS_CUBE 2

#define SHADOW_PASS_TYPE int(dvd_otherProperties.z)
#define CAMERA_FLAG SHADOW_PASS_TYPE

#define dvd_ClusterSizeX dvd_lightingProperties.x
#define dvd_ClusterSizeY dvd_lightingProperties.y
#define dvd_LightScale dvd_lightingProperties.z
#define dvd_LightBias dvd_lightingProperties.w
#define dvd_cameraForward vec3(dvd_ViewMatrix[3].xyz)
#define windowWidth int(dvd_ViewPort.z)
#define windowHeight int(dvd_ViewPort.w)

#define dvd_ClusterSizes vec2(dvd_ClusterSizeX, dvd_ClusterSizeY)

#define dvd_screenDimensions dvd_ViewPort.zw
#define dvd_invScreenDimensions (1.0f / dvd_screenDimensions)
#define dvd_aspectRatio dvd_cameraPosition.w
#define dvd_zPlanes dvd_renderProperties.xy
#define dvd_fieldOfView dvd_renderProperties.z
#define dvd_time int(dvd_renderProperties.w)

#define dvd_materialDebugFlag int(dvd_otherProperties.x)
#define dvd_ClipPlaneCount int(dvd_otherProperties.w)

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

#if defined(TESS_CTRL_SHADER)
#define CLIP_OUTPUT(X) gl_out[gl_InvocationID].gl_ClipDistance[X]
#else
#define CLIP_OUTPUT(X) gl_ClipDistance[X]
#endif

#define CLIP_INDEX(X) CLIP_OUTPUT(X) = (count > X) ? dot(_out._vertexW, dvd_clipPlanes[X]) : 0.0f

#if defined(HAS_CLIPPING_OUT) && MAX_CLIP_PLANES > 0
void setClipPlanes() {
    const int count = dvd_ClipPlaneCount;
    CLIP_INDEX(0);
#if MAX_CLIP_PLANES > 1
    CLIP_INDEX(1);
#if MAX_CLIP_PLANES > 2
    CLIP_INDEX(2);
#if MAX_CLIP_PLANES > 3
    CLIP_INDEX(3);
#if MAX_CLIP_PLANES > 4
    CLIP_INDEX(4);
#if MAX_CLIP_PLANES > 5
    CLIP_INDEX(5);
#endif 
#endif
#endif
#endif
#endif
}
#else //HAS_CLIPPING_OUT && MAX_CLIP_PLANES > 0
#define setClipPlanes()
#endif //HAS_CLIPPING_OUT && MAX_CLIP_PLANES > 0
#endif //!COMPUTE_SHADER && !FRAG_SHADER

#endif //_NODE_DATA_INPUT_CMN_

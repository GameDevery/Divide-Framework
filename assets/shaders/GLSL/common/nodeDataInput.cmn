#ifndef _NODE_DATA_INPUT_CMN_
#define _NODE_DATA_INPUT_CMN_

#include "utility.cmn"

#if defined(PRE_PASS) || defined(SHADOW_PASS)
#   define DEPTH_PASS
#endif

#if defined(GEOM_SHADER)
#define InBlock gl_in[];
#else //GEOM_SHADER
#define InBlock gl_in[gl_MaxPatchVertices];
#endif //GEOM_SHADER

#if defined(TESS_CTRL_SHADER)
#define OutBlock gl_out[];
#else //TESS_CTRL_SHADER
#define OutBlock ;
#endif //TESS_CTRL_SHADER

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

#if defined(GEOM_SHADER) || defined(TESS_CTRL_SHADER) || defined(TESS_EVAL_SHADER)
in gl_PerVertex
{
  vec4  gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[MAX_CLIP_PLANES];
  float gl_CullDistance[MAX_CULL_DISTANCES];
} InBlock
#endif //GEOM_SHADER || TESS_CTRL_SHADER || TESS_EVAL_SHADER

out gl_PerVertex
{
  invariant vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[MAX_CLIP_PLANES];
  float gl_CullDistance[MAX_CULL_DISTANCES];
} OutBlock

#endif //!COMPUTE_SHADER && !FRAG_SHADER

// This could be split up in the future into frequent-infrequent blocks depending on update rate
layout(binding = BUFFER_GPU_BLOCK, std140) uniform dvd_GPUBlock
{
    mat4  dvd_ProjectionMatrix;
    mat4  dvd_InverseProjectionMatrix;
    mat4  dvd_ViewMatrix;
    mat4  dvd_InverseViewMatrix;
    mat4  dvd_ViewProjectionMatrix;
    mat4  dvd_PreviousViewProjectionMatrix;
    ///xyz - position, w - aspect ratio
    vec4  dvd_cameraPosition; 
    vec4  dvd_ViewPort;
    //x - nearPlane, y - farPlane, z - FoV, w - elapsed time (ms)
    vec4  dvd_renderProperties;
    //x - cluster size X, y - cluster size Y, z - scale, w - bias
    vec4  dvd_lightingProperties;
    //x - material debug flag, y - fog enabled, z - camera flag, w - clip plane count
    vec4  dvd_otherProperties;
    vec4  dvd_frustumPlanes[6];
    vec4  dvd_clipPlanes[MAX_CLIP_PLANES];
    vec4  _gpu_padding0[10];
};

#define SHADOW_PASS_NORMAL 0
#define SHADOW_PASS_ORTHO 1
#define SHADOW_PASS_CUBE 2

#define dvd_fogEnabled (int(dvd_otherProperties.y) == 1)
#define SHADOW_PASS_TYPE int(dvd_otherProperties.z)
#define CAMERA_FLAG SHADOW_PASS_TYPE

#define dvd_LightScale dvd_lightingProperties.z
#define dvd_LightBias dvd_lightingProperties.w
#define dvd_cameraForward vec3(dvd_ViewMatrix[3].xyz)
#define windowWidth int(dvd_ViewPort.z)
#define windowHeight int(dvd_ViewPort.w)

#define dvd_ClusterSizes dvd_lightingProperties.xy

#define dvd_screenDimensions dvd_ViewPort.zw
#define dvd_invScreenDimensions (1.f / dvd_screenDimensions)
#define dvd_aspectRatio dvd_cameraPosition.w
#define dvd_zPlanes dvd_renderProperties.xy
#define dvd_fieldOfView dvd_renderProperties.z
#define dvd_time int(dvd_renderProperties.w)

#define dvd_materialDebugFlag int(dvd_otherProperties.x)
#define dvd_ClipPlaneCount int(dvd_otherProperties.w)

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

#if defined(TESS_CTRL_SHADER)
#define CLIP_OUTPUT(X) gl_out[gl_InvocationID].gl_ClipDistance[X]
#define OUT _out[gl_InvocationID]
#else
#define CLIP_OUTPUT(X) gl_ClipDistance[X]
#define OUT _out
#endif

#define CLIP_INDEX(X) CLIP_OUTPUT(X) = (dvd_ClipPlaneCount > X) ? dot(OUT._vertexW, dvd_clipPlanes[X]) : 0.f

void setClipPlanes() {
    CLIP_INDEX(0);
#if MAX_CLIP_PLANES > 1
    CLIP_INDEX(1);
    #if MAX_CLIP_PLANES > 2
        CLIP_INDEX(2);
        #if MAX_CLIP_PLANES > 3
            CLIP_INDEX(3);
            #if MAX_CLIP_PLANES > 4
            CLIP_INDEX(4);
                #if MAX_CLIP_PLANES > 5
                CLIP_INDEX(5);
                #endif 
            #endif
        #endif
    #endif
#endif
}
#endif //!COMPUTE_SHADER && !FRAG_SHADER

#define BitCompare(MASK, BIT) ((MASK & BIT) != 0)

#endif //_NODE_DATA_INPUT_CMN_

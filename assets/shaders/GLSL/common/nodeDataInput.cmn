#ifndef _NODE_DATA_INPUT_CMN_
#define _NODE_DATA_INPUT_CMN_

#if defined(PRE_PASS) || defined(SHADOW_PASS)
#define DEPTH_PASS
#endif

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)
out gl_PerVertex
{
  invariant vec4 gl_Position;
#if defined(USE_POINT_SIZE)
  float gl_PointSize;
#endif
#if defined(USE_CUSTOM_CLIP_PLANES)
  float gl_ClipDistance[MAX_CLIP_PLANES];
#endif
#if defined(USE_CULL_DISTANCE)
  float gl_CullDistance[MAX_CULL_DISTANCES];
#endif
#if defined(TESS_CTRL_SHADER)
} gl_out[];
#else //defined(TESS_CTRL_SHADER)
};
#endif //defined(TESS_CTRL_SHADER)

#if defined(GEOM_SHADER) || defined(TESS_CTRL_SHADER) || defined(TESS_EVAL_SHADER)
    in gl_PerVertex
    {
      vec4  gl_Position;
#if defined(USE_POINT_SIZE)
      float gl_PointSize;
#endif
#if defined(USE_CUSTOM_CLIP_PLANES)
      float gl_ClipDistance[MAX_CLIP_PLANES];
#endif
#if defined(USE_CULL_DISTANCE)
      float gl_CullDistance[MAX_CULL_DISTANCES];
#endif
    }
    #if defined(GEOM_SHADER)
    gl_in[];
    #else //defined(GEOM_SHADER)
    gl_in[gl_MaxPatchVertices];
    #endif //defined(GEOM_SHADER)
#endif

#endif //!defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)

// This could be split up in the future into frequent-infrequent blocks depending on update rate
layout(binding = BUFFER_GPU_BLOCK, std140) uniform dvd_GPUBlock
{
    mat4  dvd_ProjectionMatrix;
    mat4  dvd_InverseProjectionMatrix;
    mat4  dvd_ViewMatrix;
    mat4  dvd_InverseViewMatrix;
    mat4  dvd_ViewProjectionMatrix;
    mat4  dvd_PreviousViewProjectionMatrix;
    ///xyz - position, w - aspect ratio
    vec4  dvd_cameraPosition; 
    vec4  dvd_ViewPort;
    //x - nearPlane, y - farPlane, z - FoV, w - lightTilesX
    vec4  dvd_renderProperties;
    //x - material debug flag, y - CSM splits view index, z - camera flag, w - is ortho projection
    vec4  dvd_otherProperties;
    vec4  dvd_clip_plane[MAX_CLIP_PLANES];
};

#define DEBUG_ALBEDO 0
#define DEBUG_EMISSIVE 1
#define DEBUG_ROUGHNESS 2
#define DEBUG_METALLIC 3
#define DEBUG_NORMALS 4
#define DEBUG_SHADOW_MAPS 5
#define DEBUG_LIGHT_TILES 6
#define DEBUG_REFLECTIONS 7
#define DEBUG_NONE 8

#define SHADOW_PASS_NORMAL 0
#define SHADOW_PASS_ORTHO 1
#define SHADOW_PASS_CUBE 2

#define SHADOW_PASS_TYPE int(dvd_otherProperties.z)
#define CAMERA_FLAG SHADOW_PASS_TYPE

#define dvd_numTilesX uint(dvd_renderProperties.w)
#define dvd_cameraForward vec3(dvd_ViewMatrix[3].xyz)
#define windowWidth int(dvd_ViewPort.z)
#define windowHeight int(dvd_ViewPort.w)

#define dvd_invScreenDimensions (1.0f / dvd_ViewPort.zw)
#define dvd_zPlanes vec2(dvd_renderProperties.xy)
#define dvd_aspectRatio dvd_cameraPosition.w
#define dvd_fieldOfView dvd_renderProperties.z

#define dvd_materialDebugFlag int(dvd_otherProperties.x)
#define dvd_CSMSplitsViewIndex int(dvd_otherProperties.y)
#define dvd_IsOrthoProjection (int(dvd_otherProperties.w) == 1)

struct WaterBodyData {
    vec4 positionW;
    vec4 details;
};

layout(binding = BUFFER_SCENE_DATA, std430) coherent readonly buffer dvd_SceneData
{
    // x,y,z - colour, w - density
    vec4   dvd_fogDetails;
    // x,y,z - direction, w - speed
    vec4   dvd_windDetails;
    //x - light bleed bias, y - min shadow variance, z - fade distance, w - max distance
    vec4   dvd_shadowingSettings;
    //x - elapsed time (ms), y - delta time (ms), z - debug render, w.x - reserved
    vec4   dvd_otherData;
    WaterBodyData dvd_waterEntities[];
};

#define dvd_LightBleedBias dvd_shadowingSettings.x
#define dvd_MinVariance dvd_shadowingSettings.y
#define dvd_fogColour dvd_fogDetails.rgb
#define dvd_fogDensity dvd_fogDetails.w
#define dvd_time int(dvd_otherData.x)
#define dvd_deltaTime (int(dvd_otherData.y))
#define dvd_showDebugInfo (uint(dvd_otherData.z) == 1)

#if !defined(COMPUTE_SHADER) && !defined(FRAG_SHADER)
#if defined(USE_CUSTOM_CLIP_PLANES)
void setClipPlanes(in vec4 worldSpaceVertex) {
    for (int i = 0; i < MAX_CLIP_PLANES; ++i) {
#   if defined(TESS_CTRL_SHADER)
        gl_out[gl_InvocationID].gl_ClipDistance[i] = dot(worldSpaceVertex, dvd_clip_plane[i]);
#   else
        gl_ClipDistance[i] = dot(worldSpaceVertex, dvd_clip_plane[i]);
#   endif
    }
}
#else
#define setClipPlanes(X)
#endif //USE_CUSTOM_CLIP_PLANES
#endif

#if 0
vec2 UNPACK_UINT(in uint value) {
    return vec2(
        (value >> 16) / 65535.0f,
        (value & 0xFFFF) / 65535.0f);
}
#endif

//mix(false, true, condition);

#endif //_NODE_DATA_INPUT_CMN_
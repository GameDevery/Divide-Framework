layout(binding = TEXTURE_DEPTH_MAP) uniform sampler2D HiZBuffer;

vec4 BoundingBox[8];

int PassThrough(const in vec3 position, const in vec3 extents) {
    return 1;
}

int InstanceCloudReduction(const in vec3 position, const in vec3 extents) {
    const float frustumBias = 0.5;

    // create the bounding box of the object 
    BoundingBox[0] = dvd_ViewProjectionMatrix * vec4(position + vec3( extents.x,  extents.y,  extents.z), 1.0);
    BoundingBox[1] = dvd_ViewProjectionMatrix * vec4(position + vec3(-extents.x,  extents.y,  extents.z), 1.0);
    BoundingBox[2] = dvd_ViewProjectionMatrix * vec4(position + vec3( extents.x, -extents.y,  extents.z), 1.0);
    BoundingBox[3] = dvd_ViewProjectionMatrix * vec4(position + vec3(-extents.x, -extents.y,  extents.z), 1.0);
    BoundingBox[4] = dvd_ViewProjectionMatrix * vec4(position + vec3( extents.x,  extents.y, -extents.z), 1.0);
    BoundingBox[5] = dvd_ViewProjectionMatrix * vec4(position + vec3(-extents.x,  extents.y, -extents.z), 1.0);
    BoundingBox[6] = dvd_ViewProjectionMatrix * vec4(position + vec3( extents.x, -extents.y, -extents.z), 1.0);
    BoundingBox[7] = dvd_ViewProjectionMatrix * vec4(position + vec3(-extents.x, -extents.y, -extents.z), 1.0);

    // check how the bounding box resides regarding to the view frustum 
    uvec2 outOfBoundX = uvec2(0);
    uvec2 outOfBoundY = uvec2(0);
    uvec2 outOfBoundZ = uvec2(0);

    vec4 crtBB;
    float frustumLimit = 0.0;
    for (uint i = 0; i < 8; i++) {
        crtBB = BoundingBox[i];
        frustumLimit = crtBB.w + frustumBias;
        if (crtBB.x >  frustumLimit) outOfBoundX[0]++;
        if (crtBB.x < -frustumLimit) outOfBoundX[1]++;
        if (crtBB.y >  frustumLimit) outOfBoundY[0]++;
        if (crtBB.y < -frustumLimit) outOfBoundY[1]++;
        if (crtBB.z >  frustumLimit) outOfBoundZ[0]++;
        if (crtBB.z < -frustumLimit) outOfBoundZ[1]++;
    }

    return (outOfBoundX[0] == 8 || outOfBoundX[1] == 8 ||
            outOfBoundY[0] == 8 || outOfBoundY[1] == 8 ||
            outOfBoundZ[0] == 8 || outOfBoundZ[0] == 8) 
            ? 0
            : 1;
}

//Return: 0 = culled, 1 = visible
int zBufferCull(const in vec3 position, const in vec3 extents) {
    /* first do instance cloud reduction */
    if (InstanceCloudReduction(position, extents) == 0) {
        return 0;
    }

    /* perform perspective division for the bounding box */
    for (int i = 0; i < 8; i++) {
        BoundingBox[i].xyz /= BoundingBox[i].w;
    }

    /* calculate screen space bounding rectangle */
    vec2 BoundingRect[2];
    BoundingRect[0].x = min(min(min(BoundingBox[0].x, BoundingBox[1].x),
                                min(BoundingBox[2].x, BoundingBox[3].x)),
                            min(min(BoundingBox[4].x, BoundingBox[5].x),
                                min(BoundingBox[6].x, BoundingBox[7].x))) / 2.0 + 0.5;
    BoundingRect[0].y = min(min(min(BoundingBox[0].y, BoundingBox[1].y),
                                min(BoundingBox[2].y, BoundingBox[3].y)),
                            min(min(BoundingBox[4].y, BoundingBox[5].y),
                                min(BoundingBox[6].y, BoundingBox[7].y))) / 2.0 + 0.5;
    BoundingRect[1].x = max(max(max(BoundingBox[0].x, BoundingBox[1].x),
                                max(BoundingBox[2].x, BoundingBox[3].x)),
                            max(max(BoundingBox[4].x, BoundingBox[5].x),
                                max(BoundingBox[6].x, BoundingBox[7].x))) / 2.0 + 0.5;
    BoundingRect[1].y = max(max(max(BoundingBox[0].y, BoundingBox[1].y),
                                max(BoundingBox[2].y, BoundingBox[3].y)),
                            max(max(BoundingBox[4].y, BoundingBox[5].y),
                                max(BoundingBox[6].y, BoundingBox[7].y))) / 2.0 + 0.5;

    /* then the linear depth value of the front-most point */
    float InstanceDepth = min(min(min(BoundingBox[0].z, BoundingBox[1].z),
                                  min(BoundingBox[2].z, BoundingBox[3].z)),
                              min(min(BoundingBox[4].z, BoundingBox[5].z),
                                  min(BoundingBox[6].z, BoundingBox[7].z)));
    /* now we calculate the bounding rectangle size in viewport coordinates */
    float ViewSizeX = (BoundingRect[1].x - BoundingRect[0].x) * dvd_ViewPort.z;
    float ViewSizeY = (BoundingRect[1].y - BoundingRect[0].y) * dvd_ViewPort.w;

    /* now we calculate the texture LOD used for lookup in the depth buffer texture */
    float LOD = ceil(log2(max(ViewSizeX, ViewSizeY) / 2.0));

    /* finally fetch the depth texture using explicit LOD lookups */
    vec4 Samples;
    Samples.x = textureLod(HiZBuffer, vec2(BoundingRect[0].x, BoundingRect[0].y), LOD).r;
    Samples.y = textureLod(HiZBuffer, vec2(BoundingRect[0].x, BoundingRect[1].y), LOD).r;
    Samples.z = textureLod(HiZBuffer, vec2(BoundingRect[1].x, BoundingRect[1].y), LOD).r;
    Samples.w = textureLod(HiZBuffer, vec2(BoundingRect[1].x, BoundingRect[0].y), LOD).r;
    float MaxDepth = max(max(Samples.x, Samples.y), max(Samples.z, Samples.w));

    /* if the instance depth is bigger than the depth in the texture discard the instance */
    return (InstanceDepth > MaxDepth) ? 0 : 1;

   
}
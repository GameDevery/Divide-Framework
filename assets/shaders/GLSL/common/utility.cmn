#ifndef _UTILITY_CMN_
#define _UTILITY_CMN_

#define ACCESS_RW
#define ACCESS_R readonly
#define ACCESS_W writeonly

#if defined(COMPUTE_SHADER)
#define COMP_ONLY_W ACCESS_W
#define COMP_ONLY_R ACCESS_R
#define COMP_ONLY_RW ACCESS_RW
#else //COMPUTE_SHADER
#define COMP_ONLY_W readonly
#define COMP_ONLY_R 
#define COMP_ONLY_RW readonly
#endif //COMPUTE_SHADER

#ifndef M_EPSILON
#define M_EPSILON 1e-5f
#endif //M_EPSILON

#ifndef M_PI
#define M_PI 3.14159265358979323846
#define INV_M_PI 0.31830988618
#endif //M_PI

//ref: http://theorangeduck.com/page/avoiding-shader-conditionals
#define when_eq(x, y) (1.0f - abs(sign(x - y)))
#define when_neq(x, y) abs(sign(x - y))
#define when_gt(x, y)  max(sign(x - y), 0.0f)
#define when_lt(x, y)  max(sign(y - x), 0.0f)
#define when_ge(x, y) (1.0f - when_lt(x, y))
#define when_le(x, y) (1.0f - when_gt(x, y))
#define AND(a, b) (a * b)
#define OR(a, b) min(a + b, 1.0f)
#define XOR(a, b) ((a + b) % 2.0f)
#define NOT(a) (1.0f - a)
#define SQUARED(X) (X * X)
#define ROUND(v) floor((v) + .5)

#define saturate(X) clamp(X, 0.f, 1.f)
#define mad(a, b, c) (a * b + c)

#define MSToSeconds(ms) (ms * 0.001f)

float maxComponent(in vec2 v) { return max(v.x, v.y); }
float maxComponent(in vec3 v) { return max(max(v.x, v.y), v.z); }
float maxComponent(in vec4 v) { return max(max(max(v.x, v.y),v.z), v.w); }


//ref: https://aras-p.info/texts/CompactNormalStorage.html#method08ppview
vec3 unpackNormal(in vec2 enc)
{
#if 1
    const vec2 fenc = enc * 4 - 2;
    const float f = dot(fenc, fenc);
    const float g = sqrt(1 - f * 0.25f);
    return vec3(fenc * g, 1 - f * 0.5f);
#else
    vec3 ret;
    ret.xy = enc * 2 - 1;
    ret.z = sqrt(1 - dot(ret.xy, ret.xy));
    return ret;
#endif
}

vec2 packNormal(in vec3 n)
{
#if 1
    const float f = sqrt(8 * n.z + 8);
    return n.xy / f + 0.5f;
#else
    return n.xy * 0.5f + 0.5f;
#endif
}

#endif //_UTILITY_CMN_
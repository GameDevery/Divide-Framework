#ifndef _UTILITY_CMN_
#define _UTILITY_CMN_

#ifndef M_EPSILON
#define M_EPSILON 0.0000001
#endif //M_EPSILON

#ifndef M_PI
#define M_PI 3.14159265358979323846
#define INV_M_PI 0.31830988618
#endif //M_PI

#ifndef F0
#define F0 vec3(0.04f)
#endif

//ref: http://theorangeduck.com/page/avoiding-shader-conditionals
#define when_eq(x, y) (1.0f - abs(sign(x - y)))
#define when_neq(x, y) abs(sign(x - y))
#define when_gt(x, y)  max(sign(x - y), 0.0f)
#define when_lt(x, y)  max(sign(y - x), 0.0f)
#define when_ge(x, y) (1.0f - when_lt(x, y))
#define when_le(x, y) (1.0f - when_gt(x, y))
#define AND(a, b) (a * b)
#define OR(a, b) min(a + b, 1.0f)
#define XOR(a, b) ((a + b) % 2.0f)
#define NOT(a) (1.0f - a)

float saturate(in float v) { return clamp(v, 0.0, 1.0); }
vec2  saturate(in vec2 v)  { return clamp(v, 0.0, 1.0); }
vec3  saturate(in vec3 v)  { return clamp(v, 0.0, 1.0); }
vec4  saturate(in vec4 v)  { return clamp(v, 0.0, 1.0); }

float maxComponent(in vec2 v) { return max(v.x, v.y); }
float maxComponent(in vec3 v) { return max(max(v.x, v.y), v.z); }
float maxComponent(in vec4 v) { return max(max(max(v.x, v.y),v.z), v.w); }

float MSToSeconds(in int ms) { return ms * 0.001f; }

//ref: https://aras-p.info/texts/CompactNormalStorage.html#method08ppview
vec3 unpackNormal(in vec2 enc)
{
#if 1
    const vec2 fenc = enc * 4 - 2;
    const float f = dot(fenc, fenc);
    const float g = sqrt(1 - f * 0.25f);
    return vec3(fenc * g, 1 - f * 0.5f);
#else
    vec3 ret;
    ret.xy = enc * 2 - 1;
    ret.z = sqrt(1 - dot(ret.xy, ret.xy));
    return ret;
#endif
}

vec2 packNormal(in vec3 n)
{
#if 1
    const float f = sqrt(8 * n.z + 8);
    return n.xy / f + 0.5f;
#else
    return n.xy * 0.5f + 0.5f;
#endif
}
#endif //_UTILITY_CMN_
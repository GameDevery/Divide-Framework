#ifndef _UTILITY_CMN_
#define _UTILITY_CMN_

#ifndef M_EPSILON
#define M_EPSILON 0.0000001
#endif //M_EPSILON

#ifndef M_PI
#define M_PI 3.14159265358979323846
#define INV_M_PI 0.31830988618
#endif //M_PI

#ifndef F0
#define F0 vec3(0.04f)
#endif

//ref: http://theorangeduck.com/page/avoiding-shader-conditionals
#define when_eq(x, y) (1.0f - abs(sign(x - y)))
#define when_neq(x, y) abs(sign(x - y))
#define when_gt(x, y)  max(sign(x - y), 0.0f)
#define when_lt(x, y)  max(sign(y - x), 0.0f)
#define when_ge(x, y) (1.0f - when_lt(x, y))
#define when_le(x, y) (1.0f - when_gt(x, y))
#define AND(a, b) (a * b)
#define OR(a, b) min(a + b, 1.0f)
#define XOR(a, b) ((a + b) % 2.0f)
#define NOT(a) (1.0f - a)

float saturate(in float v) { return clamp(v, 0.0, 1.0); }
vec2  saturate(in vec2 v)  { return clamp(v, 0.0, 1.0); }
vec3  saturate(in vec3 v)  { return clamp(v, 0.0, 1.0); }
vec4  saturate(in vec4 v)  { return clamp(v, 0.0, 1.0); }

float maxComponent(in vec2 v) { return max(v.x, v.y); }
float maxComponent(in vec3 v) { return max(max(v.x, v.y), v.z); }
float maxComponent(in vec4 v) { return max(max(max(v.x, v.y),v.z), v.w); }

float MSToSeconds(in int ms) { return ms * 0.001f; }

//ref: https://aras-p.info/texts/CompactNormalStorage.html#method08ppview
vec3 unpackNormal(in vec2 enc)
{
#if 1
    const vec2 fenc = enc * 4 - 2;
    const float f = dot(fenc, fenc);
    const float g = sqrt(1 - f * 0.25f);
    return vec3(fenc * g, 1 - f * 0.5f);
#else
    vec3 ret;
    ret.xy = enc * 2 - 1;
    ret.z = sqrt(1 - dot(ret.xy, ret.xy));
    return ret;
#endif
}

vec2 packNormal(in vec3 n)
{
#if 1
    const float f = sqrt(8 * n.z + 8);
    return n.xy / f + 0.5f;
#else
    return n.xy * 0.5f + 0.5f;
#endif
}

#ifndef COLORMAP_SH_HEADER_GUARD
#define COLORMAP_SH_HEADER_GUARD

// Copyright 2019 Google LLC.
// SPDX-License-Identifier: Apache-2.0

// Polynomial approximation in GLSL for the Turbo colormap
// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f

// Authors:
//   Colormap Design: Anton Mikhailov (mikhailov@google.com)
//   GLSL Approximation: Ruofei Du (ruofei@google.com)

// See also: https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html

vec3 turboColormap(float x) {
    // show clipping
    if (x < 0.0)
        return vec3(0.0);
    else if (x > 1.0)
        return vec3(1.0);

    const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);
    const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);
    const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);
    const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);
    const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);
    const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);

    x = saturate(x);
    vec4 v4 = vec4(1.0, x, x * x, x * x * x);
    vec2 v2 = v4.zw * v4.z;
    return vec3(
        dot(v4, kRedVec4) + dot(v2, kRedVec2),
        dot(v4, kGreenVec4) + dot(v2, kGreenVec2),
        dot(v4, kBlueVec4) + dot(v2, kBlueVec2)
    );
}

#endif // COLORMAP_SH_HEADER_GUARD

#endif //_UTILITY_CMN_
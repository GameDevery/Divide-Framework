#ifndef _NODE_BUFFERED_INPUT_CMN_
#define _NODE_BUFFERED_INPUT_CMN_

struct NodeData {
    mat4 _worldMatrix;
    // [0][0] ... [2][2] = normal matrix
    // [0][3] = bone count
    // [3][0] ... [3][3] = bounding sphere
    mat4 _normalMatrix;
    // [0][0] ... [0][3] = albedo
    // [1][0] ... [1][3] = specular
    // [2][0] ... [2][3] = emissive
    // [3][0] = is translucent
    // [3][1] = texture operation
    // [3][2] = texture count
    // [3][3] = parallax factor
    mat4 _colorMatrix;
    // x = selection flag
    // y = is shadow received
    // z = lod level
    // w = reserved
    vec4 _properties;
};

layout(binding = BUFFER_NODE_INFO, std430) coherent readonly buffer dvd_MatrixBlock
{
    NodeData dvd_Matrices[MAX_VISIBLE_NODES];
};

mat4 dvd_WorldMatrix() {
    return dvd_Matrices[VAR.dvd_drawID]._worldMatrix;
}

mat3 dvd_NormalMatrix() {
    return mat3(dvd_Matrices[VAR.dvd_drawID]._normalMatrix);
}

ivec4 dvd_BufferIntegerValues() {
    return ivec4(dvd_Matrices[VAR.dvd_drawID]._properties);
}

#if defined(VERT_SHADER)
#define dvd_boneCount     uint(dvd_Matrices[VAR.dvd_drawID]._normalMatrix[0][3])
#endif

// x - isSelected/isHighlighted; y - isShadowMapped; z - lodLevel, w - occlusion cull data
#define dvd_lodLevel dvd_BufferIntegerValues().z

#if defined(FRAG_SHADER)
// x - useAlphaTest; y - textureOperation; z - textureCount, w - parallax/relief mapping factor
#define buffer_matProperties dvd_Matrices[VAR.dvd_drawID]._colorMatrix[3]

#define dvd_isSelected     (dvd_BufferIntegerValues().x < -0.5)
#define dvd_isHighlighted  (dvd_BufferIntegerValues().x >  0.5)
#define dvd_shadowMapping  (dvd_BufferIntegerValues().y > 0.0)
#define dvd_useAlphaTest   (buffer_matProperties.x > 0.0)
#define dvd_texOperation   uint(buffer_matProperties.y)
#define dvd_textureCount   uint(buffer_matProperties.z)
#define dvd_parallaxFactor buffer_matProperties.w
#define dvd_reliefFactor   dvd_parallaxFactor

#endif

#endif //_NODE_BUFFERED_INPUT_CMN_

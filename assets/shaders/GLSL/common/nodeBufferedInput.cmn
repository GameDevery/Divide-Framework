#ifndef _NODE_BUFFERED_INPUT_CMN_
#define _NODE_BUFFERED_INPUT_CMN_

#include "nodeDataDefinition.cmn"

#if defined(OVERRIDE_DATA_IDX)
uniform uint DATA_IDX = 0u;
#else
#define DATA_IDX VAR.dvd_baseInstance
#endif

layout(binding = BUFFER_NODE_INFO, std430) coherent readonly buffer dvd_MatrixBlock
{
    NodeData dvd_Matrices[MAX_VISIBLE_NODES];
};

#define dvd_WorldMatrix(index) dvd_Matrices[index]._worldMatrix
#define dvd_NormalMatrixW(index) mat3(dvd_Matrices[index]._normalMatrixW)
#define dvd_NormalMatrixWV(index) (mat3(dvd_ViewMatrix) * dvd_NormalMatrixW(index))

#define dvd_boneCount uint(dvd_Matrices[DATA_IDX]._normalMatrixW[0][3])
#define dvd_texOperation uint(dvd_Matrices[DATA_IDX]._extraProperties.x)
#define dvd_bumpMethod uint(dvd_Matrices[DATA_IDX]._extraProperties.y)

// x - reserved; y - parallax factor, z - lod level, w - data
#define buffer_matProperties dvd_Matrices[DATA_IDX]._colourMatrix[3]

// x - isSelected/isHighlighted; y - isShadowMapped; z - lodLevel, w - occlusion cull flag
#define dvd_lodLevel int(buffer_matProperties.z)
#define dvd_dataFlag int(buffer_matProperties.w)
#define dvd_parallaxFactor  buffer_matProperties.y

#if defined(FRAG_SHADER)
#define dvd_reflectionIndex uint(dvd_Matrices[DATA_IDX]._normalMatrixW[1][3])
#define dvd_refractionIndex uint(dvd_Matrices[DATA_IDX]._normalMatrixW[2][3])
#define dvd_receivesShadow  (dvd_Matrices[DATA_IDX]._colourMatrix[2][3] > 0.1f)
#endif

#endif //_NODE_BUFFERED_INPUT_CMN_

#ifndef _LIGHT_INPUT_CMN_
#define _LIGHT_INPUT_CMN_

#if defined(COMPUTE_SHADER)
#   define ACCESS
#else
#   define ACCESS readonly
#endif

const int LIGHT_DIRECTIONAL = 0;
const int LIGHT_OMNIDIRECTIONAL = 1;
const int LIGHT_SPOT = 2;

struct Light {
    /// rgb = colour
    /// w = cosOuterConeAngle
    vec4   _colour;
    /// xyz = light positon 
    /// w = range
    vec4   _positionWV; 
    /// xyz = direction(or direction for Directional lights)
    /// w = spot angle   
    vec4   _directionWV; 
    /// x = light type: 0 - directional, 1  - point, 2 - spot
    /// y = casts shadows
    /// z = reserved
    /// w = reserved
    ivec4  _options;
};

layout(binding = BUFFER_LIGHT_NORMAL, std430) coherent ACCESS buffer dvd_LightBlock
{
    // x = total light count, y = directional light count, z = point light count, w = shadow light count
    ivec4 dvd_LightData;
    Light dvd_LightSource[];
};

layout(binding = BUFFER_LIGHT_INDICES, std430) coherent ACCESS buffer perTileLightIndexBuffer
{
    uint perTileLightIndices[];
};

#define TOTAL_LIGHT_COUNT       dvd_LightData.x
#define DIRECTIONAL_LIGHT_COUNT dvd_LightData.y
#define POINT_LIGHT_COUNT       dvd_LightData.z
#define SPOT_LIGHT_COUNT        (TOTAL_LIGHT_COUNT - DIRECTIONAL_LIGHT_COUNT - POINT_LIGHT_COUNT)
#define TOTAL_SHADOW_LIGHTS     dvd_LightData.w

#if defined(FRAG_SHADER)
struct Shadow {
    // x = light type, y = csm split count, z = arrayOffset
    uvec4 _lightDetails;
    mat4  _lightVP[MAX_SPLITS_PER_LIGHT];
    vec4  _lightPosition[MAX_SPLITS_PER_LIGHT];
    float _floatValues[MAX_SPLITS_PER_LIGHT];
};

layout(binding = BUFFER_LIGHT_SHADOW, std430) coherent ACCESS buffer dvd_ShadowBlock
{
    Shadow dvd_ShadowSource[];
};

#endif 

#define windowWidth int(dvd_ViewPort.z)
#define windowHeight int(dvd_ViewPort.w)

// calculate the number of tiles in the horizontal direction
uint GetNumTilesX()
{
    return uint((windowWidth + FORWARD_PLUS_TILE_RES - 1) / float(FORWARD_PLUS_TILE_RES));
}

// calculate the number of tiles in the vertical direction
uint GetNumTilesY()
{
    return uint((windowHeight + FORWARD_PLUS_TILE_RES - 1) / float(FORWARD_PLUS_TILE_RES));
}

uint GetTileIndex(in vec2 ScreenPos)
{
    float fTileRes = float(FORWARD_PLUS_TILE_RES);
    return uint(floor(ScreenPos.x / fTileRes) + floor(ScreenPos.y / fTileRes) * GetNumTilesX());
}

Light dvd_private_light;

#endif //_LIGHT_INPUT_CMN_
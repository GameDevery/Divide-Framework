const int LIGHT_DIRECTIONAL = 0;
const int LIGHT_OMNIDIRECTIONAL = 1;
const int LIGHT_SPOT = 2;


struct LightPhysical {
    vec4  _attenuation; //< x = constAtt, y = linearAtt, z = quadraticAtt,  w = brightness
    vec4  _position;    //< Position is a direction for directional lights. w-light type: 0.0 - directional, 1.0  - point, 2.0 - spot
    vec4  _direction;   //< xyz = Used by spot lights, w = spotExponent
    float _spotCutoff;
};

layout(binding = SHADER_BUFFER_LIGHT_NORMAL, std140) uniform dvd_LightBlock
{
    LightPhysical dvd_LightSourcePhysical[MAX_LIGHTS_PER_SCENE];
};

layout(binding = SHADER_BUFFER_LIGHT_PER_NODE, std140) uniform dvd_PerNodeLights
{
    uvec4 dvd_perNodeLightData[MAX_LIGHTS_PER_NODE]; //x = lightIndex, y = lightType, z = castsShadows, w = totalCount
};

#if defined(FRAG_SHADER)

struct LightVisual {
    vec4 _diffuse;     //< rgb = diffuse,  w = ambientFactor;
    vec3 _specular;    //< rgb = specular color
};

layout(binding = SHADER_BUFFER_LIGHT_COLOR, std140) uniform dvd_LightBlockColor
{
    LightVisual dvd_LightSourceVisual[MAX_LIGHTS_PER_SCENE];
};

struct Shadow {
    mat4  _lightVP0;
    mat4  _lightVP1;
    mat4  _lightVP2;
    mat4  _lightVP3;
    vec4  _floatValues;
    vec4  _lightPosition[4];
};

layout(binding = SHADER_BUFFER_LIGHT_SHADOW, std140) uniform dvd_ShadowBlock
{
    Shadow dvd_ShadowSource[MAX_LIGHTS_PER_SCENE];
}; 

uniform vec4 dvd_lightAmbient;
uniform bool dvd_enableShadowMapping = false;
#endif

#if defined(VERT_SHADER)
#define VARYING out
#elif defined(FRAG_SHADER)
#define VARYING in
#endif

/// Light Info is used internally to communicate between vertex and fragment shaders
VARYING LightInfo {
    vec3  _lightDirection[MAX_LIGHTS_PER_NODE];
    smooth float _attenuation[MAX_LIGHTS_PER_NODE];
    flat uint _lightCount;
} _lightInfo;

VARYING vec3 _normalWV;
VARYING vec3 _viewDirection;

#ifndef _LIGHT_INPUT_CMN_
#define _LIGHT_INPUT_CMN_

const int LIGHT_DIRECTIONAL = 0;
const int LIGHT_OMNIDIRECTIONAL = 1;
const int LIGHT_SPOT = 2;
const int LIGHT_NONE = 3;

struct Light {
    /// rgb = colour
    /// w = cos(outer cone angle)
    vec4   _colour;
    /// xyz = light position (spot and omni. 0,0,0 for directional)
    /// w = range (radius for point lights)
    vec4   _positionWV; 
    /// xyz = direction (spot and directional, 0,0,0 for omni)
    /// w = cos(inner cone angle)
    vec4   _directionWV; 
    /// x = light type: 0 - directional, 1  - point, 2 - spot, 3 - none
    /// y = shadow index (-1 = no shadows)
    /// z = spot cone slant height
    /// w = reserved
    ivec4  _options;
};

#define _TYPE _options.x
#define _SHADOW_INDEX _options.y
#define _SPOT_CONE_SLANT_HEIGHT _options.z

layout(binding = BUFFER_LIGHT_NORMAL, std430) coherent ACCESS_R buffer dvd_LightBlock
{
    Light dvd_LightSource[];
    //RenderDoc: vec3 colour; float cosOuterCone; vec3 positionWV; float range; vec3 directionWV; float spotAngle; int lightType; int castsShadows; ivec2 null;
};

layout(binding = BUFFER_LIGHT_SCENE, std140) uniform dvd_LightSceneDataBlock
{
    // x = directional light count, y = point light count, z = spot light count, w = shadow light count
    uvec4 dvd_LightData;
    vec4  dvd_AmbientColour;
    mat4 _light_padding0[3]; 
    vec4 _light_padding1[2];
};

#define DIRECTIONAL_LIGHT_COUNT dvd_LightData.x
#define POINT_LIGHT_COUNT       dvd_LightData.y
#define SPOT_LIGHT_COUNT        dvd_LightData.z
#define CLUSTERS_COUNT          CLUSTERS_X * CLUSTERS_Y * CLUSTERS_Z

#if defined(FRAG_SHADER) || defined(COMPUTE_SHADER)
struct LightGrid
{
    uint offset;
    uint countPoint;
    uint countSpot;
    uint _padding;
};

layout(binding = BUFFER_LIGHT_GRID, std430) buffer lightGridSSBO
{
    LightGrid lightGrid[];
};

layout(binding = BUFFER_LIGHT_INDICES, std430) COMP_ONLY_RW buffer lightIndexSSBO {
    uint globalLightIndexList[];
};

#if defined(COMPUTE_SHADER)
struct VolumeTileAABB
{
    vec4 minPoint;
    vec4 maxPoint;
};

#if defined(COMPUTE_LIGHT_CLUSTERS)
#define LIGHT_CLUSTER_ACCESS COMP_ONLY_RW
#else //COMPUTE_LIGHT_CLUSTERS
#define LIGHT_CLUSTER_ACCESS COMP_ONLY_R
#endif
layout(binding = BUFFER_LIGHT_CLUSTER_AABBS, std430) LIGHT_CLUSTER_ACCESS buffer lightClusterAABBs
{
    VolumeTileAABB cluster[];
};
#else //COMPUTE_SHADER

float ToLinearDepth(in float depthIn);

// cluster depth index from depth in screen coordinates (gl_FragCoord.z)
uint GetClusterZIndex(float screenDepth) {
    const float eyeDepth = ToLinearDepth(screenDepth);

    return uint(max(log2(eyeDepth) * dvd_LightScale + dvd_LightBias, 0));
}

uint GetClusterIndex(vec4 fragCoord) {
    const uint zIndex = GetClusterZIndex(fragCoord.z);
    uvec3 indices = uvec3(uvec2(fragCoord.xy / dvd_ClusterSizes), zIndex);

    return (CLUSTERS_X * CLUSTERS_Y) * indices.z +
            CLUSTERS_X * indices.y +
            indices.x;
}

#endif //COMPUTE_SHADER

#endif //FRAG_SHADER || COMPUTE_SHADER

#endif //_LIGHT_INPUT_CMN_

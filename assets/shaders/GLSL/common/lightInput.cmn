#ifndef _LIGHT_INPUT_CMN_
#define _LIGHT_INPUT_CMN_

#if defined(COMPUTE_SHADER)
#   define ACCESS
#   define COMP_RW writeonly
#else
#   define ACCESS readonly
#   define COMP_RW readonly
#endif

const int LIGHT_DIRECTIONAL = 0;
const int LIGHT_OMNIDIRECTIONAL = 1;
const int LIGHT_SPOT = 2;
const int LIGHT_NONE = 3;

struct Light {
    /// rgb = colour
    /// w = cosOuterConeAngle
    vec4   _colour;
    /// xyz = light positon 
    /// w = range
    vec4   _positionWV; 
    /// xyz = direction(or direction for Directional lights)
    /// w = spot angle   
    vec4   _directionWV; 
    /// x = light type: 0 - directional, 1  - point, 2 - spot, 3 - none
    /// y = shadow index (-1 = no shadows)
    /// z = reserved
    /// w = reserved
    ivec4  _options;
};

layout(binding = BUFFER_LIGHT_NORMAL, std430) coherent ACCESS buffer dvd_LightBlock
{
    // x = directional light count, y = point light count, z = spot light count, w = shadow light count
    uvec4 dvd_LightData;
    Light dvd_LightSource[MAX_LIGHTS];
    //RenderDoc: vec3 colour; float cosOuterCone; vec3 positionWV; float range; vec3 directionWV; float spotAngle; int lightType; int castsShadows; ivec2 null;
};

layout(binding = BUFFER_LIGHT_INDICES, std430) coherent COMP_RW buffer perTileLightIndexBuffer
{
    int perTileLightIndices[];
};

#if defined(FRAG_SHADER)

layout(binding = BUFFER_LIGHT_SHADOW, std140) uniform dvd_ShadowBlock
{
    // x = light type, y =  arrayOffset
    uvec4 dvd_shadowLightDetails[MAX_SHADOW_CASTING_LIGHTS];
    vec4  dvd_shadowLightPosition[MAX_SHADOW_CASTING_LIGHTS * 6];
    mat4  dvd_shadowLightVP[MAX_SHADOW_CASTING_LIGHTS * 6];
};

#endif 

uint GetTileIndex(in vec2 ScreenPos)
{
    ivec2 location = ivec2(ScreenPos.xy);
    ivec2 tileID = location / ivec2(FORWARD_PLUS_TILE_RES, FORWARD_PLUS_TILE_RES);
    return uint(tileID.y * LIGHT_NUM_TILES_X + tileID.x);
}

#endif //_LIGHT_INPUT_CMN_